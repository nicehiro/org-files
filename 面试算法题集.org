#+HUGO_BASE_DIR: ~/Documents/hugo-static/
#+hugo_section: notes
#+hugo_auto_set_lstmod: t
#+TITLE: 面试算法题集
#+DATE: 2018-03-25
#+OPTIONS: toc:nil

** 数组与字符串
- 实现一个算法，确定一个字符串所有字符都不相同。
  1. 转为 char 数组，一个一个比较
  2. 使用散列表
  3. 排序

- 两字符串，确定在重新排序之后，其中一个是否可以变成另一个字符串。
  1. 统计字符的个数，与另一个字符串相比
  2. 排序，然后查看是否 equals

- 将字符串中的空格全部替换为“%20”。假定字符串尾部有足够大的空间，也知道字符串的“真实”长度。
  #+BEGIN_QUOTE
  题目明显提到了“尾部有足够的空间”，一定要考虑从尾部开始重排字符串，这样做可以不用移动后面的字符串。
  #+END_QUOTE
  1. 如上解释的，扫描两次，第一次取得空格的次数，计算出替换后的字符串的长度；第二次从最后面开始将字符串重新写入数组

- 利用字符重复出现的次数，实现基本的字符串压缩功能。
  1. 扫描一次，遇到与上一个字符相同的字符，count++；如果不同，count 置 1，将字符与 count 写入新字符串，使用 StringBuilder 优化字符操作

- 若 MxN 矩阵中某个元素为 0，则将其所在行和列全部清零。
  1. 最简单的方法：遍历所有元素，将 0 所在列清完，O(MN)
  2. 再用一个标记矩阵，如果有行为 0，在标记矩阵上记录，最后一并清理

- 假定有一个方法 isSubString, 可检查一个单词是否为其他字符串的字串。给定字符串 s1 和 s2，检查 s1 是否可以有 s2 旋转而成。
  1. 不好想出个办法，需要奇思淫计。将两个 s1 拼合，如果满足题中条件，那么 s2 必然是两个 s1 的字串

** 链表
- 移除未排序链表中的重复节点。
  1. 将节点保存到 hash table 中，遍历
  2. 两个指针，一个指向当前节点，一个遍历之后的节点

- 找出单向链表中倒数第 k 个节点。
  1. 如果已知长度，好做
  2. 长度不已知，定义两个指针，相差 k 个节点，当一个指针到达链表结尾时，另一个指针就是倒数第 k 个节点

- 删除单向链表中的某个节点，你只能访问到这个节点。
  1. 将这个节点之后的节点复制到前一个节点上

- 给定 x，分割链表。
  1. 创建两个链表，一个放大于等于 x 的；另一个小于 x 的

- 给定用链表表示的整数，编写函数对两个整数求和，并用链表返回结果。
  1. 编写函数，将链表转为数；编写函数，将数转为链表
  2. 使用加法法则，计算有进位加法

- 给定有环链表，返回环路的开发节点。
  - 经典算法。两个指针，fast 和 slow，fast 一次移动两个节点，slow 一次移动一个节点；当 slow 走到环路口时，fast 比 slow 快（设开头到环路有 x，环路长度有 r）x，相对而言，slow 可以说是比 fast 快 r-x；因此再经过 r-x 之后，slow 和 fast 位于环中同一位置，且距环起始处 x，所以此时一个节点调回链表起始处同时出发，若再次相遇，则此节点就是环路的开始节点

- 检查链表是否为回文
  1. 反转 比较

** 栈与队列
-
