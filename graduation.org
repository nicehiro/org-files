* Emacs 网易云音乐插件开发

** 摘要
Emacs不仅仅是一个编辑器，它是一个集成环境，或可称它为集成开发环境，这些功能如让用户置身于全功能的操作系统中，比如上网浏览网页、做 GTD 的管理、完美集成 Org-mode 等功能都可以在 Emacs 中完成。

Emacs 就像一个伪装称编辑器的操作系统，它几乎可以做日常操作系统的绝大部分工作，如文件管理（Dired Mode），邮件阅读（Wander Lust等），浏览器（EWW），音视频播放器（EMMS）等等功能，只有你想不到，没有它做不到。Emacs的哲学很特殊，它不是为了“方便大众”而来的，而是为了功能和可扩展性。它不会为了让所有人都能接受它而委屈自已，它会试图让自己变得很强大，而不考虑普通人是否有能力驾驭它。所谓“All in Emacs”就是指这个。

对于程序员，你可以学习最古老至今仍在发挥功效（人工只能领域）的 Lisp 语言来配置属于自己的 Emacs；对于作家，你可以使用最强大的文本编辑语言 Org-mode （Markdown 比不了的）和与此最融洽的编辑器 Emacs 来完成自己的文章（几乎可以导出任何格式）；就算你什么都不是，你仍然可以使用 Org-mode 来完成日常生活的 GTD（Get Things Done!） 规划……

Emacs 下有一款非常强大的媒体播放 package —— EMMS（Emacs Multimedia System），可以播放本地音乐文件和流媒体音乐文件，这个项目一开始就是在 EMMS 的基础上完成的（后来改换成自己编写的播放进程）。

此 Package 基于开源网易云音乐 API，为 Emacs 开发了相应的网易云音乐插件，可以实现登录、听歌、搜索歌曲、查看自己的播放列表、显示歌词等功能。

** 绪论

*** 研究目的与意义
自从接触 Emacs 之后就一直想要为 Emacs 开发一款听流媒体音乐的 Package。恰好 Github 上关于网易云音乐的 API 文档很全，因此便投入进来了。本插件需要实现的功能是：登录自己的网易云音乐账号，查看自己的所有歌单，查看歌单中的音乐，播放音乐与歌曲 MV，搜索歌曲，搜索艺人，播放私人 FM 歌单等。

目前在 Melpa 上，国内还没有一款对应的播放器，国外的有 Spotify 插件。因此开发 Emacs 网易云音乐插件就很必要了。

*** 国内外研究现状
1984年，美国国家工程院院士斯托曼开始致力于开发GNU Emacs，Emacs 具有强大的功能，并签署了 GPL 协议来保障 Emacs 可以永久的被人们自由分发和使用。之后 Emacs 便迅速传播，吸引大批互联网黑客加入到开发 Emacs 的热潮中，他们为 Emacs 添加新的功能（Package）、提出 Issues，使得 Emacs 日益完善，成为最全能的编辑器之一。GNU Emacs 后来被移植到了Unix系统上一个真正的 Lisp 作为扩展语言。结果，GNU Emacs 很快就取代了 Gosling Emacs，成为 Unix 系统上默认的 Emacs编辑器。

到1999年为止，GNU Emacs的开发工作基本是在封闭的情况下进行。这种开发方式被称为“大教堂模式”。从那以后，GNU Emacs项目创建了公共开发邮件列表和匿名CVS代码访问，开发工作在一个CVS代码仓库中进行。2008年，Emacs开始使用Bazaar进行版本控制。2008年，斯托曼将代码的维护工作交给了 Stefan Monnier和 Chong Yidong。

不管是国内还是国外，Emacs 的使用人数实在是非常的少。2016年，Emacs 黑客（id：子龙山人）推出了一系列的关于Emacs的视频教程，非常非常适合新手上手 Emacs；之后不久，又推出了由其维护的Emacs-China中文社区，进一步使得喜欢 Emacs 的用户增多，其论坛讨论气氛非常活跃，解决问题也很及时。另外，有 Emacs 爱好者收集并翻译国内外优秀的 Emacs 相关文章、博客，托管在 Github，大大方便了英语薄弱的同学的 Emacs 学习。

目前国内还没有一款可以实现流媒体播放的 Emacs 插件，最开始有这个构想是在刚接触 Emacs 的时候。那时候，网易云音乐没有为 Linux 操作系统开发相应便捷的客户端应用，几个月之后，就和深度（Deepin）Linux 合作开发了网易云音乐 Linux 社区版，虽然满足了日常听歌需要，但还是非常不稳定，间歇性直接卡死。再后来，darknessomi 同学使用 Python 开发了第一款基于命令行的网易云音乐客户端（API应该是自己破解的），使用体验真的叫如丝般顺滑，唯一可惜的是它只能在 Terminal 中使用；再之后，Binaryify 同学写了网易云音乐 Node.js API 服务并一直维护至今，有了这个文档细致的 API 服务之后，许许多多第三方网易云音乐客户端犹如雨后出笋般出现在 Github 上，本 Package 也是基于此 API 进行的开发。

* 研究内容与论文结构


** 成功破解API，但使用繁琐
这里我通过抓包与参考很多同学分享的经验，基本了解了网易云音乐的 API 请求是如何加密的。
网易云音乐新版 API 大概可以这样表示：
=http://music.163.com/weapi/= + 具体请求 url + 请求参数（加密的）。

请求参数是一个被加密的 Json 格式的字符串，具体的参数有 limit（返回数据条数限制）、offset（偏移数量）、csrf_token（值可为空）、total（true）。实际请求的参数最后加密的格式为：
={'params': ..., 'encSecKey': ...}= 。其中 csrf_token 我通过浏览器 cookie 取到的。

其中，params 的加密是两次 AES 加密：首先将具体请求的参数与加密字段“nonce”进行一次 AES 加密，然后再使用加密后的字段与 =secKey= 进行第二次 AES 加密，其中 =secKey= 是16位随机生成的字母或数字。

encSecKey 的加密方式是 RSA 加密：RSA 加密采用非常规填充方式，既不是 PKCS1 也不是 PKCS1_OAEP，网易的做法是直接向前补0，这样加密出来的密文有个特点：加密过程没有随机因素，明文多次加密后得到的密文是相同的。然而，我们常用的 RSA 加密模块均不支持此种加密，所以需要手写一段简单的 RSA 加密。

之后尝试着写了一段代码，实现获取自己喜欢的艺人的信息，请求结果如下：
[[file:~/Pictures/2018-04-30-140452_1848x780_scrot.png][musician-info]]

** 改用开源 API
于是便有了想法，从零开始搭建一个 Python 的网易云音乐 API 服务器。但又一想，既然有了破解 API 的思路，Github 上也应该会有对应实现的 API 服务，一搜，果然有一个 stars 上千的项目。那么便不再考虑重新造轮子了。直接使用 Binaryify 同学写好的 Netease Music Node Js Api Service。

** 搭建到服务器
*** 退出登录时，当前服务自动关闭问题解决
    在阿里云搭建了一台 API 服务器，方便之后写代码的测试。在服务器搭建好 API 服务之后，远程请求服务倒是成功了，但是每次退出服务器的时候，当前的 api 服务也会随之关闭，搜索资料之后，找到了解决方法：

每次退出服务器的时候，终端程序会发起一个 SIGHUP（挂断）信号，使所有正在运行的程序都挂起，因此 API 服务不能持久运行。

#+BEGIN_SRC sh
nohup command > netease-api.log &
#+END_SRC

nohup 可以是进程不挂断的运行； & 可以使进程在后台运行；> 可以是进程的所有输出写到指定文件中。

** 使用 Elisp 解析
*** Emacs 特性
buffer window autoload list debug mode-line
为 Emacs 开发插件，需要先对 Emacs 的一些基本操作对象做一些了解。
**** Emacs buffer
在 Emacs 中编辑的一切文件都被建立在内存中一个 Emacs buffer 对象中，每个缓冲区都有一个唯一的名称，可以是任意长度。当窗口中显示缓冲区时，其名称显示在模式行（mode line）中。缓冲区名称中大写和小写之间的区别。每个缓存区都有一个主要模式（Major Mode）和若干个次要模式（Minor Mode），不同的模式决定这个 buffer 中内容如何存在，或是这个 buffer 有什么特殊的功能。你只能选取一个 buffer 进行工作。

**** Emacs window
每个窗口可以显示一个缓存区，而一个缓存区可以出现在多个窗口中；这些窗口可以显示缓存区的不同位置。Emacs 可以将一个 frame 分割成多个窗口，多个窗口可以显示不同缓存区的部分。窗口的类别有几种不同的类型，一种是最基本的窗口，另一种是弹出窗口（Popup window）。弹出窗口是一种特殊的窗口，弹出之后。光标调到新的弹出窗口，然后在这个窗口完成你要执行的操作之后，按 q 可以直接退出窗口。

弹出窗口用作搜索歌曲的结果来说非常有效！搜索完毕，直接退出——用完即走，你可以在使用 Emacs 做其他事的时候，搜索完成，播放歌曲之后，按 q 再回到现在工作的窗口。这样做可以最大程度的提高工作效率。

**** Emacs autoload 机制
自动加载机制可以自动加载一部分函数，而推迟加载这个函数的文件。当第一次调用这个函数时，会去自动加载这个函数所需要的软件包和其他相关的代码，而不需要加载定义这个函数的整个文件。这样做，可以加快 Emacs 的启动速度，减少 Emacs 占用的内存。因此，自动加载很有必要的。

自动加载机制实现最快捷的方法实在需要自动加载函数前加上“魔法注释”——“;;;autoload”即可。一遍来说，需要自动加载的函数一般有：
- major mode 或是 minor mode 的定义
- 一些交互式命令

在第一次提交到 melpa 时，melpa 的维护者提出了建议，让我加上 autoload 再进行合并。

**** Emacs List
Lisp 语言中有一个特殊的对象 Cons —— 可以使用 Cons 来构造成列表（List），然后列表可以形成其他不同数据结构。

Cons 可以想象成链表中的结点这样的数据结构，只不过这个结点只有两个指针，分别可以使用“car”、“cdr”访问这两个指针所指向的内容。而 List 就是有多个 Cons（结点）组成的，它最后一个结点的“cdr”指向为空。你可以使用 List 组成其他很多的数据结构，比如说是 Map 对象 —— 

**** Debug
Emacs debug 方式有点类似 gcc 的 debug —— 其实所有语言的 debug 都一样，只不过不少工具的存在使得 debug 变得图形化而使我第一次使用这个而感到有些生疏了。

首先需要打开 Emacs 全局调试开关：M-x toggle-debug-on-error，这样当 Emacs 出错的时候会进入 debug 模式。可以在想要 debug 的语句之前加“(debug)”来添加断点；d 可以单步执行，e 求值，将结果显示在 Minibuffer 中；q 退出 debug。

**** Emacs mode line
每个窗口底部都有一个模式行（mode line），它描述了当前缓存区正在进行的操作——文件状态、文件名、当前位置、当前 Major Mode 和当前 Minor Mode 等。初步设计的音乐播放想要实现的功能是，在模式行上能动态显示当前播放歌曲的信息。

模式行上的字符都是有一些全局变量来组成的，而与我们需要实现功能相关的那个变量叫：global-mode-string。一般来说，这个变量跟在 which-func-mode 次要模式之后，否则就在模式行的主要模式之后。如果需要在模式行显示当前时间，我们可以调用 display-time 这个函数，而这个函数其实就是将 global-mode-string 设置为了引用变量：display-time-string。这样，如果我们要显示当前播放歌曲，那么可以将 global-mode-string 设置为当前播放歌曲名即可。

*** 宏优化代码
Emacs Lisp 的宏可以实现“用我们写的代码生成可以执行的代码”的功能。
Emacs Lisp 作为 Lisp 的一种方言，最出名的自然也是其宏系统了。在 Lisp 中，程序和代码的表现形式几乎一致，这就使得 Emacs 具备了非常好的元编程能力。

在 Emacs Lisp 中，程序的读入与执行是两个操作。同样，也就对应这两种不同的表达式——自求值表达式和其他。一般来说，函数都是自求值表达式，比如 =(setq test 1)= 可以直接被 Emacs 读入并执行；而 =(1 2 3)= 被执行时就会出错。需要只读入这个表达式的话可以使用 =quote= 函数或者是 ='= 将表达式l括起来。

这样，宏编程就可以实现了。下面这段代码是我用宏来优化我项目中重复的代码的：

#+BEGIN_SRC elisp
(defmacro test-format-args (url-name args)
  `(defun ,(format "format-%s-args" url-name) (,url-name ,@args)
     (format ,url-name ,@args)))
#+END_SRC

反引号的作用和单引号的作用差不多，但在反引号中，可以使用 =,= 对参数求值，使用 =,@= 对 list 分解（取出 list 中的元素）。

上诉宏表达式使用宏展开的结果(test-format-args test-url (test-args1 test-args2))是：

#+BEGIN_SRC elisp
(defun format-test-url-args (test-url test-args1 test-args2)
  (format test-url test-args1 test-args2))
#+END_SRC
这样，通过一个宏就可以生成多个函数形式差不多的 format 函数，可以 format 不同的 url。

** 播放音乐的解决方案
*** 播放列表的实现
Lisp 中一切数据对象都可以通过列表（list）来实现，表达式无非是一个特殊的 list（第一个参数可以调用其他的参数的列表）。包括在其他语言中所谓的类。定义一个歌曲类，设置类实例的实例变量或者取出某个实例变量的值，都可以使用 slot-value 完成。如果是 Map 对象，可以使用 cons 函数将两个对象合并起来组成一个 key-value 键值对。这样，播放列表就可以实现了：以歌曲 id 与歌曲实例对象组成的对象来形成播放列表。

*** mplayer 如何调用
最开始使用的是 Emacs 集成的一个音乐播放包 EMMS，非常强大，可以通过配置使用 mplayer、mpv 等多款播放器播放音乐。后来，研究了一下 Emacs 中如何使用线程，实现了一个调用 mplayer 的线程去播放音乐。

一个异步进程通过一个 pty（伪终端）或者是一个管道进行控制。Emacs 中可以使用 make-process 或者是 start-process 来新建一个进程，可以将写入的命令（Command）传到伪终端调用执行。

进程标示（Process sentinel）是一个函数，只要关联的进程由于任何原因发生状态的改变——这些改变包括进程终止、进程退出等，就会调用该函数。这个标示函数接收两个参数，一个是需要关联的进程，另一个是描述事件发生状态的字符串。通常有如下的描述事件发生的字符串：“finished\n”、“deleted\n”、“exited”等。因此，每次播放完一首歌之后，进程就会返回一个描述当前进程状态的字符串，通过识别这个字符串是否为“finished”来决定，或者是回调“play-next”这个函数，从而也就可以实现循环播放。

*** 如何实现歌词滚动
由于当前的 Emacs （version：25.*）还是单线程，所以如果添加歌词滚动的话，会使 Emacs 变得卡顿；另外毕竟 Emacs 是一个编辑器，听歌只能说是 Emacs 的附带功能，歌词滚动会让我们使用 Emacs 初心变了。因此不再添加此功能。

*** 歌曲重复的问题
最开始的构想是：新建一个 buffer，buffer 中的每一行都显示一首歌曲的名字；另外维护一个歌曲列表（或许叫做 Map 更加形象一些），使用歌曲名字作为 Map 的 Key，歌曲信息实例作为 Value；要播放当前歌曲时，获取所在行的文本，然后去歌曲列表中查找相应的歌曲详情（主要是找到歌曲 id），请求链接就可以播放了。

上诉这样的做法看起来是没有问题的，但是当有两首歌曲歌名相同时候（翻唱），上诉的方法就会出现莫名其妙的问题：相同的歌曲信息会被后加入进列表的歌曲覆盖，使得歌曲跳转有时会失败，播放的歌曲不会更新。

解决这个问题的方法也很简单：使用歌曲 id 作为 Map 的 Key 来存入歌曲列表，而歌曲 id 一定是唯一的。但是又会引发新的问题，在播放列表的 buffer 里，你不应该直接把歌曲 id 暴露给用户，那么该如何使用户 id 隐性的记录在播放列表 buffer 中呢？

幸好 Emacs 自带的一个主要模式（Major Mode）Org-mode 中有一种显示链接的方法，它的具体格式是这样的：
#+BEGIN_SRC
[[隐藏的链接或文本][显示的文本]]
#+END_SRC
这样，我们可以自定义自己的 Major Mode（netease-music），继承自 Org-mode，将歌曲名放在需要显示的文本中，歌曲 id 放在影藏的文本中，最后实现的效果是这样的：
[[file:~/Documents/netease-music/images/songs.png][songs]]

之后，写一个正则表达式就可以准确识别到歌曲 id 了。

** 发布到 Melpa
比较常见的三个package仓库有ELPA, Marmalade, 和MELPA. ELPA是GNU官方的仓库,Emacs天生支持该仓库. 相比之下Marmalade 和 MELPA 都是第三方的仓库. 各个仓库之间都有一些不同之处,最大的不同在于它们对版权的处理方式.

ELPA 和 Marmalade 都要求所有的package都遵守GPL 或 GPL-兼容的 协议. 而且, ELPA还要求你签署一份 FSF 版权申明. MELPA则对你的版权没有要求,不过它会对所有新增的 package 都进行代码审核以保障质量.

Melpa（Milkypostman’s Emacs Lisp Package Archive）是目前 Emacs 最大的包管理中心，它只需要包作者提供一份简单的清单（recipe），上面写好包名和项目所在的链接即可。如果审核通过，MELPA 服务器会自动从你项目的所在地址更新你的项目到 MELPA 服务器。通常来说，发布到 MELPA，意味着你的项目得到了 Emacser 的认可。由于 MELPA 上面的包更新很勤快，使用人数也是最多，所以我选择发布到 MELPA。

*** 文档规范检查
- Package 命名
  最好就选 library 的名字。
- 添加发布协议
  我选了 GPL 协议。GPL 协议的一些重要原则：
1、确保软件自始至终都以开放源代码形式发布，保护开发成果不被窃取用作商业发售。任何一套软件，只要其中使用了受 GPL 协议保护的第三方软件的源程序，并向非开发人员发布时，软件本身也就自动成为受 GPL 保护并且约束的实体。也就是说，此时它必须开放源代码。
2、GPL 大致就是一个左侧版权（Copyleft，或译为“反版权”、“版权属左”、“版权所无”、“版责”等）的体现。你可以去掉所有原作的版权 信息，只要你保持开源，并且随源代码、二进制版附上 GPL 的许可证就行，让后人可以很明确地得知此软件的授权信息。GPL 精髓就是，只要使软件在完整开源 的情况下，尽可能使使用者得到自由发挥的空间，使软件得到更快更好的发展。
3、无论软件以何种形式发布，都必须同时附上源代码。例如在 Web 上提供下载，就必须在二进制版本（如果有的话）下载的同一个页面，清楚地提供源代码下载的链接。如果以光盘形式发布，就必须同时附上源文件的光盘。
4、开发或维护遵循 GPL 协议开发的软件的公司或个人，可以对使用者收取一定的服务费用。但还是一句老话——必须无偿提供软件的完整源代码，不得将源代码与服务做捆绑或任何变相捆绑销售。
- Emacs Lisp 语法规约
  - 使用“包名 + -- + 变量名”表示这个变量只能属于此 Package 内部使用，外部不能调用它。

- check-doc 检查
发布之前必须使用 check-doc 检查自己的项目中是否有些函数没有写注释文档；是否注释文档写的不完全等。

- elint

- package-lint

- byte-compile-file
检查 Emacs 编译错误

*** 发布
在 Github 上 Fork MELPA 官方项目，编写自己的包清单，然后提交 Request，请求合并到 MELPA。之后，会有 MELPA 的维护者（大多时候是 Steve Purcell）初步审核你的代码，并提出一些修改建议。你可以接受这些建议，也可以不接受但要提出你自己的看法，如果合情合理，那么维护者会通过的。

[[file:~/Pictures/2018-04-30-112259_1029x725_scrot.png][publish to melpa]]

** 展望
会一直维护这个 Package 直到网易云音乐下次升级 API。

* 参考文献

file:///home/hiro/Downloads/%E7%94%B5%E5%AD%90%E4%B8%96%E7%95%8C-%E5%AF%B9%E5%BC%80%E6%BA%90%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%8E%A2%E8%AE%A8%20.pdf
对开源发展现状及未来的探讨

GPL

语法规约

