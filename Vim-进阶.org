#+HUGO_BASE_DIR: ~/Documents/blog/
#+hugo_section: notes
#+hugo_auto_set_lstmod: t

#+TITLE: Vim 进阶

#+DATE: 2017-08-09
#+OPTIONS: toc:nil

在接触 Emacs 不久之后，我结识了 Emacs 中一个很神奇的插件——Evil，这东西基本上可以将 Vim 的所有特性、操作（当然是我目前掌握的）都包含进去了。但在看 evil 文档介绍的时候，我发现我原先掌握的 Vim 操作技巧实在是太少了[fn:1]，连一个插件都用不灵光。于是就决定顺便 Hack 一下 Vim。看的书是 Drew Neil 写的 《Vim使用技巧》。以下内容不断更新，我只记录一些当下我觉得神奇有用超级快速的东西，顺便也可以系统的学一下 Vim。

#+TOC: headlines 2

** 复合命令
很多命令其实都是复合命令，或许你用的不要繁琐的命令其实可以用 VIM 内置的复合命令就可以直接搞定。   
+ A: $a
+ c: di
+ C: c$
+ S: ^C
+ I: ^i
+ o: A<CR>
+ O: ko   

** 特殊命令

+ c: clear 从当前位置
+ f: search from current cursor
+ F: 在行内查找上一个指定的字符
+ t: 后缀命令 比如 =yt,= 指复制当前光标到 , 的所有内容
+ ;: 重复上一次的查询操作 f t F T
+ ,: 反方向查找 f 
+ *: 查找当前光标所在单词 可以配合 =cw= 进行逐个修改操作
+ b: 到当前单词开头
+ e: 到当前单词结尾
+ w: 这个单词
+ ga: 查看当前字符的字符编码
+ R: 进入替换模式
+ <C-a>|<C-x>: 对数字执行加减操作 神奇的是很聪明 可以直接判断是一个几位数
  
** 组合命令

+ guaw|gUaw: 反转一个单词的大小写
+ daw: delete a word 切记需要三个同时使用
+ gg=G: 自动缩进全文
  
** 插入模式下的命令

+ <C-h>: 相当于 BackSpace
+ <C-w>: 删除一个单词
+ <C-u>: 删除整行
+ <C-o>: 执行普通模式下的一个命令 然后退回插入模式
+ <C-r>{register}: 当前光标处插入寄存器的内容
+ <C-v>{code}: code 字符编码 插入一个字符
+ <C-k>{digraph}: 利用二合字母插入非常用字符
  + <C-k>?I -> 反问号
  + <C-k>12 -> 分数 LateX 不就是干这个的吗...
    
** 可视模式

+ 面向字符、面向行、面向块的可视模式
+ o: 切换活动的端点
  
** EX 命令 | 命令行模式

+ %: 所有行
+ .: 当前行地址
+ 1: 第十行
+ $: 最后一行
+ 0: 虚拟行 位于文件第一行上方
+ '<: 高亮选区的开始行
+ '>: 高亮选区的结束行
+ <C-d>: 自动补全命令 可以结合 Tab 使用
+ |: 执行两个命令
  
** 缓存区

+ ls: 列出缓存区列表
  + %: 当前可见缓存区
  + #: 可切换缓存区
+ bnext|bprev|bfirst|blast: 操作缓存区列表 顾名思义
+ buffer N|{buffername}: 切换缓存区
+ bdelete: 删除缓存区

** 技巧
*** 对一行中某一特定字符做修改
先使用 =f= 来查找，然后修改第一处;使用 =;= 重复查找，使用 =.= 重复修改

*** 可重复操作及其回退
+ f/F/t/T 行内查找操作: ; & ,
+ /pattern<CR> 全文查找操作: n & N
+ :s/pattern/replace 全局替换 & & u
  
*** 重新映射 CapsLock 键
Why：误触那个键将会产生不同的命令，比如说最常用的 j、k 移动操作会因此而改变
J: 拼接上下两行
K: 查看当前光标处单词的 help 文档
*** Vim 与 Shell 交互
有三种方法。
+ 在 vim 的命令行模式下输入 =:!{command}= 时可以运行 shell 中的命令。
+ 命令行模式下输入 =:shell= 可以进入 shell， =exit= 退出 shell
+ =C-z= 挂起 vim，fg 恢复 vim 进程，可以使用 =jobs= 查看当前挂起进程
+ =read !{cmd}= 将 cmd 执行的结果插入到当前缓存区
+ =write !{cmd}= 执行当前缓存区中的每行内容
  
*** 相对于活动目录打开一个文件
=%= 这个可以代表当前打开文件路径，比如说我正在编辑 init.el 文件:

#+BEGIN_SRC vim command-line mode
:e %<TAB>
-> :e .emacs.d/init.el
#+END_SRC

但是我只需要 =.emacs.d= 目录，不要跟着后面的文件名，可以这样来：

#+BEGIN_SRC vim command-line mode
:e %:h<TAB>
-> :e .emacs.d
#+END_SRC

*** 超级移动
**** 手势
标准手势对 VIM 操作很有帮助，左手四指对应：a , s , d , f ，右手四指对应：j , k , l , ; 。

不要因为 h,j,k,l 是 VIM 移动命令就轻易改变手势的键位，后面我们会发现 h,l 使用移动字符是很慢的（一个字符一个字符的移动），所以不如使用基于单词的移动快速，因而较少使用 h,l 是可以活得很舒服的。

**** 屏幕行 & 实际行
如果使用 VIM 编辑一些文本文件，比如说 markdown 文件，此时我会选择启用 =wrap= 模式，可以把一行的文字（实际行）折行显示到屏幕上（屏幕行）。这样做的话，j,k 上下移动的只是实际行，移动到指定屏幕行位置的文字需要使用移动单词命令（或 h,l）来实现，但这样的效率是很低下的。

在基本移动命令前加 =g= 前缀就可以实现基于屏幕行的移动了。
+ gj/gk/: 向下/向上移动一个屏幕行
+ g0/g^/g$: 移动到屏幕行首端/第一个非空字符/末尾

**** 基于单词的移动
告别使用 h,l 左右移动
+ w: 移动到下一个单词的开头
+ b: 移动到上一个单词的开头
+ e: 移动到下一个单词的结尾
+ ge: 移动到上一个单词的结尾

**** 行内查找单词
+ f{char}: 查找下一个字符
+ F{char}: 查找上一个字符
  
如果我们查找的字符是一个非常见字符，那么查找到你想要的那个位置就会快的多。
**** 文本对象
v 进入可视模式，然后就可以选择文本对象了。
+ a 加其他符号，例如 =)= , =}= , ='= 会将它们包起来的内容以及这些符号选中
+ 与上面 a 一样，只是不会选中符号本身

运用上面所说，可以使用 =daw= 删除一个单词，包括其后的空格，如果用 =diw= 会留下两个空格；使用 =ciw= 修改一个单词，不会删除空格，而使用 =caw= 则会删除空格。
**** 设置位置标记
使用 =:m{a-zA-Z}= 或是 =:mark{a-zA-Z}= 可以为当前位置设置一个位置标记，小写字母设置仅在当前缓存区生效，大写字母全局生效。

使用 =`{a-zA-Z}= 可以跳转回那个位置标记。

使用 =``= 可以在两个标记之前来回跳转。
** Tips 详解

*** rename-files
在 vim 中重命名文件名，看完之后只是觉得思想不错，但还是不如 shell 中直接来的方便。

#+BEGIN_SRC vim command_line
## 将 ls 命令输出的结果读出到当前缓存区
:r !ls *.c

## % 指每一行
## s 替换
## 正则表达式替换 *.c 为 *.bla
## \1 指前面 () 中的东西
## & 指前面整个被匹配的字符串
:%s/\(.*\).c/mv & \1.bla

## 将当前缓存区的每一行在 shell 中执行
:w !sh
#+END_SRC

* 脚注
[fn:1] 我的 Vim 上道教程看得是陈皓大神翻译的 [[http://coolshell.cn/articles/5426.html][简明 VIM 练级攻略]]
