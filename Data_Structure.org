#+TITLE: 数据结构
#+OPTIONS: toc:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/home/hiro/Documents/org-files/worg.css"/>
#+EXPORT_FILE_NAME: ~/Documents/org-files/org-html/Data-structure.html
#+DATE: 2018-11-10

* 基础知识点
- 数据元素 数据项 学生记录是一个数据元素，一个学生记录由多个数据项组成
- 数据类型有：原子类型、结构类型、抽象数据类型（数据对象、数据关系、基本操作）
- 数据结构有：逻辑结构、存储结构、数据的运算
- 逻辑结构：线性结构（栈、广义表等）、非线性结构（集合、树形、网状）
- 存储结构：顺序存储（随机存取）、链式存储（顺序存取）、索引存储（随机）、散列存储（随机，有冲突）
- 易错点：循环队列是用顺序表（顺序存储结构的单链表）表示的队列；栈是一种逻辑结构，可以使用顺序存储或者链式存储实现
- \(T(n) = T_1(n) + T_2(n) = O(max(f(n),g(n)))\)
- \(T(n) = T_1(n) * T_2(n) = O(f(n)*g(n))\)
* 线性表（逻辑结构）
- 顺序表：线性表的顺序存储
- 单链表：线性表的链式存储（非随机存取）
- 引入头结点的优点：无需对第一个结点进行特殊处理
- 双链表：既有next又有prior
- 循环单链表：单链表尾指针指向头结点
- 循环双链表
- 静态链表：以next=-1作为结束的标志；顺序存储，顺序存取；插入删除和其他链表一样，不移动元素，只修改指针
- 当顺序表无序，时间复杂度O(n)；顺序表有序时，时间复杂度O(log(n))
- 建立一个有序链表的最小时间复杂度是O(nlog(n))
* 栈（逻辑结构）
- 只能一端插入、删除的线性表
- 共享栈 为了有效的利用存储空间，让两个栈共享一个存储空间；对存储效率没有影响
- 易错点：注意开始时候栈顶元素的位置
- 技巧 对于n个元素进栈，出栈序列为 \(\frac{1}{n+1} C_{2n}^n\)
- 易错点：C语言中标识符的规定 第一个字符必须是大小写英文字母或者下划线，不能是数字
- 中缀表达式（对应中序遍历，左中右）
- 栈的应用 进制转换、迷宫求解、递归
* 队列
- 只允许在表的一端插入，另一端删除
- 队列操作 rear 进，front 出（rear 中不存放元素）
  + 初始条件 Q.front = Q.rear = 0
  + 进队操作 SqQueue[Q.rear] = x; Q.rear ++;
  + 出队操作 x = SqQueue[Q.front]; Q.front ++;
- 循环队列操作
  + 初始条件 Q.front = Q.rear = 0
  + 进队操作 SqQueue[Q.rear] = x; Q.rear = (Q.rear+1)%MaxSize
  + 出队操作 x = SqQueue[Q.front]; Q.front = (Q.front+1)%MaxSize
  + 队列长度 (Q.rear+MaxSize-Q.front)%MaxSize
  + 队空条件 Q.front = Q.rear
- 队满条件
  + 牺牲一个单元（rear所在的单元不放元素） (Q.rear+1)%MaxSize = Q.front
  + 增设表示元素个数的数据成员 Q.size = MaxSize
  + 增设 tag 表示是否队满
- 能由输入受限的双端队列得到而不能由输出受限的双端队列得到的是 4,1,3,2
- 能由输出受限的双端队列得到而不能由输入受限的双端队列得到的是 4,2,1,3
- 既不能由输出受限的双端队列得到也不能由输入受限的双端队列得到的是 4,2,3,1
- 易错点：用链表形式存储队列时，一般情况下，删除操作只需要修改头指针即可；但如果队列中只有一个元素，删除后队列为空，需要修改尾指针Q.rear=Q.front
- 队列的应用 缓存区
* 树与二叉树
- 结点的度 一个结点的子结点的个数
- 树的度 一棵树中结点的最大度数
- 结点的层次 从根结点开始为第一层
- 结点的高度 从根结点开始自低向上增加
- 结点的深度 从根结点开始自上向下增加
- 树的高度（深度） 从1开始
- 路径长度 路径上经过的边的个数
- 树的路径长度 所有路径长度的总和
- 易错点 度为2的树至少有三个结点；而二叉树可以为空；二叉树区分左右子树
- 二叉树的性质 \(N_0 + N_1 + N_2 = 2N_2 + N_1 + 1 => N_0 = N_2 + 1\)
- 具有n个结点的 *完全* 二叉树的高度为 \(log_2N +1\)
- 二叉树中不可能存在奇数个的度为1的结点
- 由二叉树的中序和先序、后序、层次遍历可以唯一的确定一颗二叉树
- 线索二叉树是加上线索的链表结构，他是一种物理结构
- 先序二叉树中查找前驱需要知道结点的双亲；后序二叉树中查找后继也需要知道结点的双亲
- 树的存储结构
  + 双亲表示法 静态链表，有一个单元存储双亲的位置
  + 孩子表示法 每个结点一个链表，链表中有结点的孩子结点
  + 孩子兄弟表示法 每个结点包含结点值，指向结点第一个孩子结点的指针，指向结点下一个兄弟结点的指针
- 易错点 树的后根遍历相当于二叉树的中序遍历（左根右）
- 二叉排序树的删除操作
  + 叶结点 直接删除
  + 只有一颗左子树或者右子树，使用右子树或者左子树替代
  + 有左和右子树，找右子树最左边的或者左子树最右边的替代
- 平衡二叉树的插入
  + 每次调整的对象都是最小不平衡子树
  + \(N_h\)表示深度为h的平衡树中含有的最小结点数，\(N_h = N_{h-1} + N_{h-2} + 1, N_0 = 0, N_1 = 1, N_2 = 2\)
  + 含有n个结点的平衡二叉树的最大深度是 \(log_2n\)
  + 平均查找长度 \(log_2n\)
- 非前缀编码 任何一个编码都不是其他编码的前缀

*
* 伪代码（C）
** 代码常识
- 指针 存储数据所在位置，地址
- 引用 数据
** 线性表
- 线性表中的元素是从1开始的，而数组中的顺序是从0开始的
- 线性表的顺序存储类型表述（数组定义）（静态分配）
  #+BEGIN_SRC c
    #define MaxSize 50
    typedef struct {
      ElemType data[MaxSize];
      int length;
    } SqList;
  #+END_SRC
- 线性表的顺序存储类型表述（数组定义）（动态分配）
  #+BEGIN_SRC c
    #define InitSize 20
    typedef struct {
      // 指针
      ElemType *data;
      int MaxSize, length;
    } SeqList;
    // 动态分配
    L.data = (ElemType) malloc(sizeof(ElemType) *InitSize);
    // C++ 动态分配
    L.data = new ElemType[InitSize]
  #+END_SRC
- 顺序表的插入
  #+BEGIN_SRC C
    bool ListInsert(SqList &L, int i, ElemType e) {
      // 将元素e插入到L的第i个位置；i从1开始
      if (i < 1 || i > L.length + 1)
        return false;
      if (L.length >= MaxSize)
        return false;
      // 后移
      for (int j=L.length; j>=i; j--) {
        L.data[j] = L.data[j-1];
      }
      L.data[i-1] = e;
      L.length ++;
      return true;
    }
  #+END_SRC
- 顺序表的删除
  #+BEGIN_SRC C
    bool ListDelete(SqList &L, int i, ElemType &e) {
      // 将L中第i个元素删除，赋值给e
      if (i < 1 || i > L.length)
        return false;
      e = L.data[i-1];
      // 前移
      for (int j=i; j<L.length; j++)
        L.data[j-1] = L.data[j];
      L.length --;
      return false;
    }
  #+END_SRC
** 单链表
- 结点定义
  #+BEGIN_SRC C
    typedef struct LNode {
      ElemType data;
      struct LNode *next;
    } LNode, *LinkedList;
  #+END_SRC
- 头插法
  #+BEGIN_SRC C
    LinkedList createList1(LinkList &L) {
      // 带头结点的单链表
      LNode *s; int x;
      L = (LinkedList)malloc(sizeof(LNode));
      L -> next = null;
      scanf("%d", &x);
      while (x != 9999) {
        s = (LNode*)malloc(sizeof(LNode));
        s -> data = x;
        s -> next = L -> next;
        L -> next = s;
        scanf("%d", &x);
      }
      return L;
    }
  #+END_SRC
- 尾插法
  #+BEGIN_SRC C
    LinkedList createList2(LinkedList &L) {
      int x;
      // malloc 分配出来的是指针类型
      L = (LinkedList)malloc(sizeof(LNode));
      LNode *s, *r = L;
      scanf("%s", x);
      while(x != 9999) {
        s = (LNode*)malloc(sizeof(LNode));
        s -> data = x;
        r -> next = s;
        r = s;
        scanf("%d", x);
      }
      r -> next = NULL;
      return r;
    }
  #+END_SRC
- 双链表
  #+BEGIN_SRC C
    typedef struct DNode {
      ElemType data;
      Struct DNode *prior, *next;
    } DNode, *DLinkList;
  #+END_SRC
- 静态链表
  #+BEGIN_SRC C
    #define MaxSize 50
    typedef struct {
      ElemType data;
      int next;
    } SLinkList[MaxSize];
  #+END_SRC
** 栈
- 顺序栈（顺序存储）
  #+BEGIN_SRC C
    #define MaxSize 50
    typedef struct {
      ElemType data;
      int top;
    } SqStack;
  #+END_SRC
** 队列
- 顺序队列
  #+BEGIN_SRC C
    #define MaxSize 50
    typedef struct {
      ElemType data;
      int front, rear;
    } SqQueue;
  #+END_SRC
** 二叉树
- 先序遍历
  #+BEGIN_SRC C
    void PreOrder(BiTree T) {
      if (T != NULL) {
        visit(T);
        PreOrder(T -> lchild);
        PreOrder(T -> rchild);
      }
    }
  #+END_SRC
- 中序遍历
  #+BEGIN_SRC C
    void InOrder(BiTree T) {
      if (T != NULL) {
        inOrder(T -> lchild);
        visit(T);
        inOrder(T -> rchild);
      }
    }
  #+END_SRC
- 后序遍历
  #+BEGIN_SRC C
    void PostOrder(BiTree T) {
      if (T != NULL) {
        PostOrder(T -> lchild);
        PostOrder(T -> rchild);
        visit(T);
      }
    }
  #+END_SRC
- 中序遍历的非递归
  #+BEGIN_SRC C
    void InOrder2(BiTree T) {
      // 需要借助栈
      InitStack(S);
      BiTree p = T;
      while (p || !IsEmpty(S)) {
        if (p) {
          Push(S, p);
          p = p -> lchild;
        } else {
          Pop(S, p);
          visit(p);
          p = p -> rchild;
        }
      }
    }
  #+END_SRC
- 先序遍历的非递归
  #+BEGIN_SRC C
    void PreOrder2(BiTree T) {
      InitStack(S);
      BiTree p = T;
      while (p || IsEmpty(S)) {
        if (p) {
          visit(p);
          Push(p);
          p = p -> lchild;
        } else {
          Pop(p);
          p = p -> rchild;
        }
      }
    }
  #+END_SRC
