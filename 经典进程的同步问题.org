[[file:index.org][{back to main page}]]
#+TITLE: 经典进程的同步问题

#+DATE: 2016-12-28 19:54:11

快要考试了，仔细研究了下这几个经典的进程同步问题，写下来方便自己看。

#+BEGIN_HTML
  <!--more-->
#+END_HTML

** 信号量
   :PROPERTIES:
   :CUSTOM_ID: 信号量
   :END:

信号量的引入是为了防止多个进程同时对一个临界资源访问而设立的。如果你对一个文件开两个进程去写它，它肯定会出错。信号量就是阻止有多个写的进程去写哪一个资源的。

#+BEGIN_QUOTE
  临界资源(Critical
  Resource)：各个进程之间采取互斥的方式，实现对这种资源的共享。
#+END_QUOTE

*** 分类
    :PROPERTIES:
    :CUSTOM_ID: 分类
    :END:

-  整型信号量(Binary Semaphore)：只有0，1 有两个操作，一个是
   wait(s)，操作等待，当 s 的值大于 0，就减 1；当 s 的值小于等于
   0，就挂起； 另一个是 signal(s)，释放资源，当没有进程因为等待 s
   而挂起，就加 1；

比如说，如果有个共享资源 s，进程 1 对其进行访问时，执行 wait 操作，使得
s 减 1 为 0；进程 2 由于 s 为 0，无法对共享资源 s 进行访问，只有当进程 1
完成对资源 s 的访问，执行 signal 操作，使得 s 加 1 为 1 时，进程 2
才能对 s 进行访问。

-  记录型信号量(Counting Semaphore)：
   除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程，记录型信号量是由于釆用了记录型的数据结构得名。

和 整型信号量 差不多的，只不过整型的最多只对 1 个资源进行监控，而
记录型信号量 可以对一组资源进行监控。

-  AND 型信号量

*** 信号量集
    :PROPERTIES:
    :CUSTOM_ID: 信号量集
    :END:

-  Swait(s, d, d)：在信号量集中只有一个信号量 s，允许每次申请的资源数为
   d，当现有资源数少于 d 时，不予分配；
-  Swait(s, 1, 0)：当 s >= 1 时，允许多个进程进入某个资源；当 s == 0
   时，阻止任何其他程序进入该资源；
-  Swait(s, 1, 1)：当 s > 1 时，记录型变量；当 s == 1 时，互斥信号量。

** Producer-Consumer Problem
   :PROPERTIES:
   :CUSTOM_ID: producer-consumer-problem
   :END:

生产者消费者模型。一个用来生产，保存在一个临界资源区，另一个用来消费，从临界资源区取出数据。

*** 利用 记录型信号量 解决
    :PROPERTIES:
    :CUSTOM_ID: 利用-记录型信号量-解决
    :END:

我们设立几个变量： - empty：临界资源区中空闲的缓冲区，初始值为 n； -
full：临界资源去中已经写满的缓冲区，初始值为 0； -
mutex：实现对临界资源的互斥使用，初始值为 1； -
buffer：临界资源区的缓冲池数量

#+BEGIN_EXAMPLE
    Var mutex,empty,full: semaphore:=1,n,0;     
    buffer:array[0,...,n-1] of item;
        in,out: integer:=0,0;
        begin
            parbegin
                proceducer: begin
                                repeat
                                    ...
                                producer an item nextp;
                                    ...
                                wait(empty);
                                wait(mutex);
                                buffer(in):=nextp;
                                in:=(in+1) mod n;
                                signal(mutex);
                                signal(full);
                                until false;
                            end
                consumer: begin
                              repeat
                                wait(full);
                                wait(mutex);
                                nextc:=buffer(out);
                                out:=(out+1) mod n;
                                signal(mutex);
                                signal(empty);
                                consumer the item in nextc;
                             until false;
                           end
            parend
        end
#+END_EXAMPLE

分析： - 首先，生产者和消费者不能同时对资源操作，这是由 mutex
这个信号量来控制的。也所以=wait(mutex)= 和
=signal(mutex)=必须成对的出现在一个程序里； - empty 和 full
这两个信号量也需要成对出现。执行完=wait(empty)=，空闲缓冲池减少，而满的缓冲池数量增加，所以之后执行=wait(full)=；

比如说刚开始执行时：empty = n，full =
0，因此消费者不能执行；生产者生产一个，=wait(empty)=使得=empty --=，=full ++=，此时便消费者进程便可以进行访问资源了。

*** 利用 AND 信号量 解决
    :PROPERTIES:
    :CUSTOM_ID: 利用-and-信号量-解决
    :END:

我们要做的就是替换！

#+BEGIN_EXAMPLE
    Var mutex,empty,full: semaphore:=1,n,0;
         buffer:array[0,...,n-1] of item;
        in out: integer:=0,0;
        begin
            parbegin
                producer: begin
                            repeat
                                ...
                                produce an item in nextp;
                                ...
                                Swait(empty,mutex);


                                buffer(in):=nextp;
                                in:=(in+1)mod n;
                                Ssignal(mutex,full);
                             until false;
                           end
                consumer:begin
                            repeat
                                Swait(full,mutex);
                                Nextc:=buffer(out);
                                Out:=(out+1) mod n;
                                Ssignal(mutex,empty);
                                consumer the item in nextc;
                            until false;
                          end
            parend
        end
#+END_EXAMPLE

** Reader-Writer Problem
   :PROPERTIES:
   :CUSTOM_ID: reader-writer-problem
   :END:

读者-写者问题。我们写好的文件可以被多个进程读，但不可以被多个进程写，也不可以在一个进程写的过程中读该文件。

*** 利用 记录型信号量 解决
    :PROPERTIES:
    :CUSTOM_ID: 利用-记录型信号量-解决-1
    :END:

我们定义如下变量： - rmutex：多个读文件操作的互斥信号量 -
wmutex：读写文件操作的互斥信号量 - Readcount：读文件操作的个数

#+BEGIN_EXAMPLE
    Var rmutex,wmutex: semaphore:=1,1;
        Readcount: integer:=0;
        begin
            parbegin
                Reader: begin
                            repeat
                                wait(rmutex);
                                if readcount=0 then wait(wmutex);
                                    Readcount:=Readcount+1;
                                signal(rmutex);
                                    ...
                                perform read operation;
                                    ...
                                wait(rmutex);
                                readcount:=readcount-1;
                                if readcount=0 then signal(wmutex);
                                signal(rmutex);
                            until false; end
                writer: begin
                            repeat
                                wait(wmutex);
                                perform write operation;
                                signal(wmutex);
                            until false; end
            parend
        end
#+END_EXAMPLE

分析： - 由于需要记录读进程的个数 Readcount，所以用 rmutex
来做互斥信号量； - 当且仅当 readcount ==
0，即没有一个读者进程时，可以执行=wait(wmutex)=，同理也需要成对的执行=signal=操作；
- 读进程每次读完内容需要改变 readcount； -
写进程很简单，只需要控制只有一个写进程操作就好；

*** 利用 信号量集机制 解决
    :PROPERTIES:
    :CUSTOM_ID: 利用-信号量集机制-解决
    :END:

此时的问题与前面有些不同，增加了一个限制，最多允许 RN 个读者同时读。

我们定义的变量： - L：读者数量的互斥信号量，初值为 RN； -
mx：读写进程的互斥信号量； - RN：最多允许 RN 个读者同时读；

#+BEGIN_EXAMPLE
    Var RN integer;
            L,mx: semaphore:=RN,1;
        begin
            parbegin
                reader: begin
                            repeat
                                Swait(L,1,1);
                                Swait(mx,1,0);
                                    ...
                                perform read operation;
                                    ...
                                Ssignal(L,1);
                            until false;
                        end
                writer: begin
                            repeat
                                Swait(mx,1,1;L,RN,0);
                                perform write operation;
                                Ssignal(mx,1);
                            until false;
                        end
            parend end
#+END_EXAMPLE

分析：
其实这里只需要懂前面的东西就好说了。主要是几个信号量集机制的理解： -
=Swait(L, 1, 1)=：L = RN >
1，所以此时当做是记录型信号量看。每次新开一个读进程，L 的记录值减 1； -
=Swait(mx, 1, 0)=：mx = 1时，即无写进程操作时，读进程都可以访问资源；当
mx = 0，即写进程操作时，读进程无法访问资源； - =Swait(mx, 1, 1)=：mx = 1
时，此时减 1；当 mx = 0 时，无法操作写； - =Swait(L, RN, 0)=：无 reader
进程读时，也就是 L == 0 时，结合上面那条可以操作；

** Dining-Philosophers Problem
   :PROPERTIES:
   :CUSTOM_ID: dining-philosophers-problem
   :END:

哲学家进餐问题。该问题是描述有五个哲学家共用一张圆桌,分别坐在周围的五张椅子上,在圆桌
上有五个碗和五只筷子,他们的生活方式是交替地进行思考和进餐。平时,一个哲学家进
行思考,饥饿时便试图取用其左右最靠近他的筷子,只有在他拿到两只筷子时才能进餐。
进餐完毕,放下筷子继续思考。

*** 利用 记录型信号量 解决
    :PROPERTIES:
    :CUSTOM_ID: 利用-记录型信号量-解决-2
    :END:

我们定义的变量： - chopstick：筷子的互斥信号量；

#+BEGIN_EXAMPLE
    Var chopstick: array[0,...,4] of semaphore;

    repeat
        wait(chopstick[i]);
        wait(chopstick[(i+1)mod 5]);
            ...
        eat;
            ...
        signal(chopstick[i]);
        signal(chopstick[(i+1)mod 5]);
            ...
        think;
    until false;
#+END_EXAMPLE

分析：
当哲学家饿的时候，先去拿左边的筷子，然后去拿右边的筷子，成功后，进餐；进餐完毕，先放下左边的筷子，再放下右边的筷子。但这有可能出现死锁，所有哲学家同时拿起左边筷子，同时等待右边筷子的释放，那就只能都干巴巴的看着大餐不能吃饭了。

*解决方案：* 1.
至多只允许有四位哲学家同时去拿左边的筷子,最终能保证至少有一位哲学家能够
进餐,并在用毕时能释放出他用过的两只筷子,从而使更多的哲学家能够进餐。 2.
仅当哲学家的左、右两只筷子均可用时,才允许他拿起筷子进餐。 3.
规定奇数号哲学家先拿他左边的筷子,然后再去拿右边的筷子,而偶数号哲学家则
相反。按此规定,将是 1、2 号哲学家竞争 1 号筷子;3、4 号哲学家竞争 3
号筷子。即五位
哲学家都先竞争奇数号筷子,获得后,再去竞争偶数号筷子,最后总会有一位哲学家能获
得两只筷子而进餐。

** 感受
   :PROPERTIES:
   :CUSTOM_ID: 感受
   :END:

理解更深了吧只能说是......

参考： 1. http://www.jianshu.com/p/6ddc1b238f74# 2.
http://blog.csdn.net/ljianhui/article/details/10243617 3.
http://c.biancheng.net/cpp/html/2598.html 4. Wikipedia






