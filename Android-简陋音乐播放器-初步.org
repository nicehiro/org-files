#+HUGO_BASE_DIR: ~/Documents/blog/

#+hugo_section: posts
#+hugo_auto_set_lstmod: t

#+TITLE: Android 简陋音乐播放器

#+DATE: 2016-12-08
#+OPTIONS: toc:nil

额，原本是作业的一部分，要实现一个简易的音乐播放器，一开始完全没有思路，到网上四处看帖子，总算是把基本功能实现了。可是，正如题目所说，功能实现，但看起来非常简陋。

我也打算将这个小项目分开来慢慢讲，实现一个小功能就补充一点新东西。这绝不是结束。

#+BEGIN_HTML
  <!--more-->
#+END_HTML

** 获取手机本地歌曲 & 显示
   :PROPERTIES:
   :CUSTOM_ID: 获取手机本地歌曲-显示
   :END:

首先想到的肯定是获取本地的歌曲，然后一起显示到一个 ListView 上，每个
ListView 的 Item
可以被点击，点击后可以播放歌曲。这是最开始我能想到的需求了。

由于我说过这个项目现在只是为实现功能而存在，所以没有什么交互方面的设计，没有什么界面的美观设计，当然业可以很臭逼的说这是简洁实用......

大家凑活着看吧......

*** 获取本地歌曲
    :PROPERTIES:
    :CUSTOM_ID: 获取本地歌曲
    :END:

使用=ContentResolver=的方法来查找本地歌曲：

#+BEGIN_SRC java
    Cursor cursor = contentResolver.query(
            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, null, null, null,
            MediaStore.Audio.Media.DEFAULT_SORT_ORDER
    );
#+END_SRC

我们要先自定义一个类来保存查询到的歌曲信息：

#+BEGIN_SRC java
    public class MusicInfo {
        private long id;

        private long album_id;

        private String title;

        private String artist;

        private long duration;

        private long size;

        private String url;

        private String album;

        private int isMusic;

        private boolean isFavorite = false;

        public long getId() {
            return id;
        }

        public long getAlbum_id() {
            return album_id;
        }

        public String getTitle() {
            return title;
        }

        public String getArtist() {
            return artist;
        }

        public long getDuration() {
            return duration;
        }

        public long getSize() {
            return size;
        }

        public String getUrl() {
            return url;
        }

        public String getAlbum() {
            return album;
        }

        public boolean isFavorite() {
            return isFavorite;
        }

        public void setFavorite(boolean favorite) {
            isFavorite = favorite;
        }

        public MusicInfo(long id, long album_id, String title,
                         String artist, long duration, long size, String url, String album, int isMusic) {
            this.id = id;
            this.album_id = album_id;
            this.title = title;
            this.artist = artist;
            this.duration = duration;
            this.size = size;
            this.url = url;
            this.album = album;
            this.isMusic = isMusic;
        }
    }
#+END_SRC

返回的是
Cursor（游标）对象，我们可以通过查询得到的歌曲信息保存到你预先定义好的歌曲对象中，并将所有查询到的歌曲保存到
ArrayList 中：

#+BEGIN_SRC java
    List<MusicInfo> musicInfos = new ArrayList<>();

    for (int i=0; i<cursor.getCount(); i++) {
        MusicInfo musicInfo;
        cursor.moveToNext();

        long id = cursor.getLong(cursor
                .getColumnIndex(MediaStore.Audio.Media._ID));   //音乐id

        String title = cursor.getString((cursor
                .getColumnIndex(MediaStore.Audio.Media.TITLE)));//音乐标题

        String artist = cursor.getString(cursor
                .getColumnIndex(MediaStore.Audio.Media.ARTIST));//艺术家

        long duration = cursor.getLong(cursor
                .getColumnIndex(MediaStore.Audio.Media.DURATION));//时长

        long size = cursor.getLong(cursor
                .getColumnIndex(MediaStore.Audio.Media.SIZE));  //文件大小

        String url = cursor.getString(cursor
                .getColumnIndex(MediaStore.Audio.Media.DATA));  //文件路径

        String album = cursor.getString(cursor
                .getColumnIndex(MediaStore.Audio.Media.ALBUM)); //唱片图片

        long album_id = cursor.getLong(cursor
                .getColumnIndex(MediaStore.Audio.Media.ALBUM_ID)); //唱片图片ID

        int isMusic = cursor.getInt(cursor
                .getColumnIndex(MediaStore.Audio.Media.IS_MUSIC));//是否为音乐

        if (isMusic != 0 && duration/(1000*60) >= 1) {
            musicInfo = new MusicInfo(id, album_id, title, artist, duration, size, url, album, isMusic);
            musicInfos.add(musicInfo);
        }
    }
#+END_SRC

这样我们就算是获取了本地歌曲了，接下来就是将 ArrayList 中的歌曲弄到
ListView 中去。

*** 配置 ListView
    :PROPERTIES:
    :CUSTOM_ID: 配置-listview
    :END:

配置 ListView 需要先在 xml 中写好，然后我们另外写个 Adapter 继承于
BaseAdapter，实现它的几个抽象方法：

#+BEGIN_SRC java
    /*
    这里用了 ViewHolder 来优化 ListView
    其他抽象方法很简单，这里不再赘述
    */

    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder viewHolder;
        if (convertView == null) {
            viewHolder = new ViewHolder();
            convertView = LayoutInflater.from(context).inflate
                    (R.layout.item_music_list, null);
            viewHolder.musicArtist = (TextView) convertView.findViewById(R.id.list_music_artist);
            viewHolder.musicDuration = (TextView) convertView.findViewById(R.id.list_music_duration);
            viewHolder.musicTitle = (TextView) convertView.findViewById(R.id.list_music_title);
            convertView.setTag(viewHolder);
        } else {
            viewHolder = (ViewHolder) convertView.getTag();
        }

        MusicInfo music = musicInfos.get(position);

        viewHolder.musicTitle.setText(music.getTitle());
        viewHolder.musicDuration.setText(String.valueOf(formatTime(music.getDuration())));
        viewHolder.musicArtist.setText(music.getArtist());

        return convertView;
    }

    private class ViewHolder {
        private TextView musicTitle;
        private TextView musicArtist;
        private TextView musicDuration;
    }
#+END_SRC

好了，然后就可以塞歌去 ListView 了：

#+BEGIN_SRC java
    MusicAdapter musicAdapter = new MusicAdapter(this, musicInfos);
    musicList.setAdapter(musicAdapter);
#+END_SRC

** 点击播放
   :PROPERTIES:
   :CUSTOM_ID: 点击播放
   :END:

首先说一下我们是如何让歌曲播放的：

#+BEGIN_SRC java
    // 先 new 一个 MediaPlayer 对象出来
    public static MediaPlayer mediaPlayer = new MediaPlayer();
    // 设置歌曲路径
    mediaPlayer.setDataSource(path);
    // 准备
    mediaPlayer.prepare();
    // 设置监听器，如果准备好了，开始播放
    mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
        @Override
        public void onPrepared(MediaPlayer mediaPlayer) {
            mediaPlayer.start();
        }
    });
#+END_SRC

为 ListView 设置监听器：

#+BEGIN_SRC java
    musicList.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView<?> adapterView, View view, int position, long id) {
            if (musicInfos != null) {
                if (musicInfos.get(position) != null) {
                    playMusicService(position);
                    Log.d(TAG, musicInfos.get(position).getTitle() + "开始播放");
                }
            }
        }
    });
#+END_SRC

然后就是 PlayService 了，我们希望能将歌曲的信息一带传给我们建好的
Service 里面：

#+BEGIN_SRC java
    private void playMusicService(int position) {
        MusicInfo musicInfo = musicInfos.get(position);
        Intent intent = new Intent(this, PlayerService.class);
        intent.putExtra("url", musicInfo.getUrl());
        intent.putExtra("title", musicInfo.getTitle());
        intent.putExtra("artist", musicInfo.getArtist());
        intent.putExtra("album", musicInfo.getAlbum());
        intent.putExtra("album_id", musicInfo.getAlbum_id());
        intent.putExtra("MSG", MusicConstant.MusicPlayer.START_PLAY);
        intent.putExtra("current_music_position", currentMusicPosition);

        musicProgress.setMax((int) musicInfo.getDuration());

        startService(intent);
    }
#+END_SRC

=startService= 之后启动 PlayerService，PlayerService
创建自动调用方法=onStartCommand()=，在这个方法里面我们可以解析从
MainActivity 传过来的音乐信息，因为 MediaPlayer 需要：

#+BEGIN_SRC java
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        int msg = intent.getIntExtra("MSG", 0);

        if (MusicConstant.MusicPlayer.START_PLAY == msg) {
            String musicPath = intent.getStringExtra("url");
            currentMusicPosition = intent.getIntExtra("current_music_position", 0);
            playMusic(musicPath, currentMusicPosition);
        }

        return super.onStartCommand(intent, flags, startId);
    }
#+END_SRC

然后点击音乐就可以播放了。

** 自定义播放控件
   :PROPERTIES:
   :CUSTOM_ID: 自定义播放控件
   :END:

这个东西完全是为了实现而实现......大家看看了解下技术就好，前往不要在项目中用......

大概效果：

#+ATTR_HTML: :width 600 
[[http://oeoaak94a.bkt.clouddn.com/Screenshot_20161220-221640.png]]

我们做出来就是点击某一首歌，能够在控件上面显示歌名、歌曲作者、歌曲时间以及专辑图片。
最好再有个进度条就完美了！

先确定是要在点击 ListView 的 Item 时发生的 Click 事件，所以改变 UI
的操作也就在这里调用：

#+BEGIN_SRC java
    private void changeUI(int position) {
        // 获取当前位置的 musicInfos
        MusicInfo musicInfo = musicInfos.get(position);
        String title = musicInfo.getTitle();
        String artist = musicInfo.getArtist();
        String duration = String.valueOf(MusicAdapter.formatTime(musicInfo.getDuration()));
        long albumId = musicInfo.getAlbum_id();
        long id = musicInfo.getId();

        // 预先 find 的几个控件
        musicTitle.setText(title);
        musicArtist.setText(artist);
        musicDuration.setText(duration);

        Bitmap bitmap = MediaUtil.getArtwork(this, id, albumId, true, true);
        musicAlbum.setImageBitmap(bitmap);

        musicPlayImg.setImageResource(R.drawable.pause);
    }
#+END_SRC

其他还好说，就是在设置专辑图片的时候我有点不懂：在获取的 Music
对象中只有
album\_id、album两个关于封面的属性，如何从有限的属性中获取封面的图片呢？

求助于网络： > http://blog.csdn.net/wwj\_748/article/details/9237561

代码太长，就不贴出来了

*** 按钮的点击事件
    :PROPERTIES:
    :CUSTOM_ID: 按钮的点击事件
    :END:

要实现的需求： - 如果当前是播放，UI 为暂停；如果当前是暂停，UI 为播放。
- 实现断点播放 - 下一首歌曲的实现

要实现第一条需求，我是这样做的： -
定义一个=isPlaying=布尔值，检测当前状态 -
定义一个=currentMusicPosition=，检测当前播放进度 -
定义一个=Broadcast=传输播放的进度

具体实现如下： - 点击播放/暂停

#+BEGIN_SRC java
    private void onBtnPlayClicked() {
        if (!isPlaying) {
            musicPlayImg.setImageResource(R.drawable.pause);
            playMusicService(currentPosition);
            isPlaying = true;
        } else {
            musicPlayImg.setImageResource(R.drawable.play);
            PlayerService.pauseMusic();
            isPlaying = false;
        }
    }
#+END_SRC

-  发送广播传递=currentMusicPosition=

   #+BEGIN_SRC java
       Thread thread = new Thread(new Runnable() {
       @Override
       public void run() {
           while(true) {
               sendBroadcastToProgressBar();
               Log.d(TAG, "sending...");
           }
       }
       });
       thread.start();
   #+END_SRC

   总感觉起一个线程来搞广播不是很合适......
-  实现广播接收器接收=currentMusicPosition=

   #+BEGIN_SRC java
       private class BarReceiver extends BroadcastReceiver {

       @Override
       public void onReceive(Context context, Intent intent) {
           currentMusicPosition = intent.getIntExtra("current_music_position", 0);
           Log.d(TAG, currentMusicPosition + "");
           musicProgress.setProgress(currentMusicPosition);
       }
       }
   #+END_SRC

   顺便把状态栏业给实现了，hahaha～

** 感受
   :PROPERTIES:
   :CUSTOM_ID: 感受
   :END:

写完了一个小
demo，感觉还是不错的，实现了一些小功能，后面我也会慢慢多加点新功能进去的，起码好看点......

项目源码地址： >
https://github.com/nicehiro/Netease\_Andriod/tree/master/MusicPlayer






