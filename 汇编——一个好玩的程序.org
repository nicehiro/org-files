[[file:index.org][{back to main page}]]
#+TITLE: 汇编------一个好玩的程序

#+DATE: 2016-10-04 13:49:51

在自学汇编的时候，遇到了这样的非常有意思的程序，以下贴代码：

#+BEGIN_HTML
  <!--more-->
#+END_HTML

#+BEGIN_EXAMPLE
    assume cs:code
    code segment
                mov ax,4c00h
                int 21h
        start:
                mov ax,0

        s:      nop
                nop
                mov di,offset s            ;di -> s的地址
                mov si,offset s2           ;si -> s2的地址
                mov ax,cs:[si]             ;ax -> s2的内存内容
                mov cs:[di],ax             ;s -> ax的内存内容

        s1:     jmp short s
                mov ax,0
                int 21h
                mov ax,0
        s2:     jmp short s1
                nop
    code ends
    end start
#+END_EXAMPLE

代码不是很长，但足以说明问题：以下提问：

程序能不能正常执行返回？

** 分析
   :PROPERTIES:
   :CUSTOM_ID: 分析
   :END:

-  知道在内存中数据既是指令，指令就是数据。IP指向的可以被翻译成指令。
-  JMP指令在内存中的指令代码是：EB。跳转地址计算如下：

要转移的地址的指令（内存中显示）= 要转移的地址 - JMP指令下一个字节

-  举例： http://oeoaak94a.bkt.clouddn.com/hvbm1.png 图中：EBF0是 JMP
   0008 在内存中的机器指令，EB是JMP的指令 F0 = 08 - 18 （16进制计算）

[[http://oeoaak94a.bkt.clouddn.com/hvbm2.png]]

[[http://oeoaak94a.bkt.clouddn.com/hvbm2.png]]

-  如果你还没有发现什么奇怪的事......去看看第三条，已经有程序发生了变化，这里的
   JMP 0000 是如何形成的呢？

0000 = F6 + 0A

*所以*，程序会回到start之前执行，因而可以正常返回。






