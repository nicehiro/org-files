#+HUGO_BASE_DIR: ~/Documents/hugo-static/
#+hugo_section: notes
#+hugo_auto_set_lstmod: t

#+TITLE: Java 知识点总结

#+DATE: 2018-03-25
#+OPTIONS: toc:nil
* Java 知识点总结

** 基础知识
- 修饰符范围：public > protected（包含子类） > default（本包） > private（本类）

- final：修饰类，方法，变量。它修饰的类是不能被继承，修饰的变量为常量，不能被修改

- 运算符优先级：后缀（括号、.） > 一元（++） > 乘、加 > 移位 > 关系（>=） > 逻辑（&&） > 赋值

- 重写（overwrite）：子类继承父类，改写一些方法，参数列表不能变，返回类型不能变，不能做更严格的访问限制

- 重载（override）：可以写多个构造函数，就是重载。

- 抽象类：不能有实例对象，abstract 关键字，其余都和普通类一样。可以有抽象方法，不实现，在具体的继承类中实现它。

- 多态：多个类继承同一个父类，重写某个方法；然后在新建实例对象时，使用同一个父类引用调用不同的子类对象的该方法得到不同的结果。

- 接口：只能有抽象方法，只能由 static final 变量，没有构造方法，默认方法类型是 public abstract

- 向量：类似数组，但可以不指定大小的动态数组

- String 是不可变的，在修改时会先复制；StringBuffer 是可变的，因此频繁修改时可以考虑这个；StringBuilder 是线程非安全的，StringBuffer 是线程安全的，但前者比后者快，如果不需要考虑安全，使用 StringBuilder 。

- equals() 方法，默认比较的是两个对象的引用是否相同。
  相同的对象其 hashcode 也必须相同；如果两对象 hashcode 相同，但它们并不一定相同。

- native 方法是非 java 代码实现的方法。

- 类型向下转换，这里我可以理解为强制转换，按继承顺序由上向下转换。比如 Object 对象的强制转换。

- & 和 &&，前者需要前后都求值；后者在前者求值为 true 是才去求后面的值。

- java 参数都是传值；对象传引用。

- java 中数组为空，其 length = 0，表示数组已经初始化了，但其中没有元素；否则 为 null

- == 和 equals 的区别：
  == 比较的是两对象的引用；equals 默认也是两对象的引用，但它的存在是为了让开发者去实现自己想要的

- 关于多态：如果父类、子类调用的是一个静态函数，
  那么具体执行的函数和调用的对象有关。

- 拿到当前类的类名： =super().getClass().getName()=
  拿到父类的类名： =getClass().getSuperClass().getName=

- JDK 位置：默认会放在 =/usr/lib/jvm/= ，查看 path 通过 =/etc/profile= 看

** JVM
- JVM 内存分为程序计数器（记录程序执行的位置），堆（实例对象），Java 方法栈（存放执行的 Java 方法的数据（方法的变量、方法执行的位置））、本地方法栈（同前，只不过是指 navie 方法）、静态方法区（存放静态变量等）
- =stackoverflow= 异常只会在两个方法栈中，原因是方法调用层数太多
- =outofmemery= 异常发生除了程序计数器之外的所有内存中，包括内存溢出（内存不够了）和内存泄漏（一个对象无用但无法被GC清理）

** JDK
- JDK 是 Java Development Kit，包含 JRE 等
- =PATH= 配置的是 java 、javac 等命令的路径； =CLASSPATH= 配置的是需要加载的类的路径，默认是 =.= 也就是当前路径
- Arch 中把 jdk 默认安装在了 =/usr/lib/jvm/= 路径下

** Throwable
- 有两个子类，一类 Error，一类 Exception 。
- Error 就是程序发生不可避免的错误；
- Exception 分为 RuntimeException —— 运行时异常，unchecked，比如数组越界，未找到类等；还有一种是 checked ，在编译期间就可以发现避免的异常，需要 try-catch 或 throw 到上级处理
- try-catch-finally 中，return 如果放在了 catch 中，finally 先处理完成才能 return

** Java Collection
- 这个接口有两个字接口—— =List= 和 =Set= ，另一个接口是 =Map=
- 每个 Collection 都有 iterator() 方法得到一个 Iterator 对象，通过调用 iterator.next() 可以拿到下一个对象
- List 加入元素时候是有序的，元素可以重复；Set 加入元素是无序的，元素不可以重复
- List 有 LinkedList（增删方便）、ArrayList（取数方便）、Vector（类似 ArrayList）；前两者非同步，Vector 是同步的

  命名一个同步的LinkedList， =List list = Collection.synchronizedList(new LinkedList(...))=

  ArrayList 中的变量范围是可以自动扩增的，如果需要插入大量数据时候，调用 =ensureCapacity()= 方法来提高效率

  ArrayList 每次增加 50% 的空间，Vector 每次增加 100% 的空间
- Set 是不可重复的 Collection，其中的元素的 equals 方法执行后结果都不相同
- Map 是 key-value 的键值对映射，有 HashTable（可同步）、HashMap（不可同步，hashcode 排序）和 TreeMap（自排序）

** Socket 编程
- 服务器设置 =ServerSocket= ，监听某个端口；开启 accept 方法（阻塞型）可以返回一个 socket，通过 is 等方法从管子里取数据；放返回数据为 -1 时，表示数据已读完
- 客户端配置一个 socket，端口不需要特定配置（当然也可以），但是需要配置指向的服务器的地址和端口；通过 os 等方法往管子里放数据；可以使用 =socket.shutdownOut= 结束数据传输，但仍然可以继续读
- 当然服务器也可以通过 os 往客户端写数据

*** 服务器优化
- 处理并行的客户端请求操作，让服务器一直开启；可以建立一个线程池，每次过来一个请求，从线程池里取一个线程执行取数据的操作；（操作放在一个 runnable 中）

** JDBC 编程
*** JDBC 连接步骤
- 加载数据库驱动 =Class.forName(com.mysql.jdbc.Driver=
- 获取数据库连接 =DriverManager.getConnection()=
- 设置 =preparedStatement=
- 得到 =resultSet=
- 关闭 =resultSet= =preparedstatement= =connection=

** Java web 编程
*** Servlet + Jsp 编程
最原始的方法，当初做完项目被老师一顿批……
原理：在 web.xml 先做映射，把要访问的路径映射到对应的 servlet，在 servlet 中进行相应的操作，返回对应的 jsp 页面

*** Springmvc


** Tips
- Integer 对象，超过 127 的数需要新建对象；不超过 127 的数直接取内存中原有的

- default 不能修饰变量、方法；abstract 不能修饰变量，只能修饰方法和类；

- abstract 的方法需要被继承类实现，但是 final 方法不能被继承类覆写，所以二者不能放在一起用

- 泛型在编译期间，jvm 会把泛型删除，所以不会影响程序的运行性能。

- float = 12.2 错，float=12.2f 正确；

- boolean 不能与其他任何函数转换

- =++i= 和　=i++= ：
  #+BEGIN_SRC java
  int i = 0;
  i = i ++; => i = 0
  i = ++ i; => i = 1
  #+END_SRC

** JVM
- JVM 内存分为 持久代（permanent）和 Heap Space 两块。持久代主要存放 Java 类定义信息，方法等；Heap Space 中存放实例对象，分为年老代和年轻代。对年老代的回收叫做 Full GC，对年轻代的回收叫做 Young GC。
