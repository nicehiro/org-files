[[file:index.org][{back to main page}]]
#+TITLE: 单件模式详解

#+DATE: 2017-02-07 16:42:28

确保类只有一个实例，并提供一个全局获取方法。

话说这个模式是我见得最早的一个设计模式，因此也感觉最亲切，实现最简单。

#+BEGIN_HTML
  <!--more-->
#+END_HTML

** 抽象结构
   :PROPERTIES:
   :CUSTOM_ID: 抽象结构
   :END:

[[http://oeoaak94a.bkt.clouddn.com/singleton.png]]

** 最简单的单件模式
   :PROPERTIES:
   :CUSTOM_ID: 最简单的单件模式
   :END:

#+BEGIN_SRC java
    public class Singleton {
        private static Singleton singleton;
        public static Singleton getInstance() {
            // TODO

            if (singleton == null) {
                singleton = new Singleton();
            }
            return singleton;
        }
    }
#+END_SRC

如此便确保只能获取一个实例。

** 改进1
   :PROPERTIES:
   :CUSTOM_ID: 改进1
   :END:

其实上面的案例足以应对大多数情况，但是，它还是又漏洞的。

当有两个线程需要执行这段代码时：

======= 此处需补图 =======

因此可以改进如下：

#+BEGIN_SRC java
    public class Singleton {
        private static Singleton singleton = new Singleton();

        public static Singleton getInstance() {
            return singleton;
        }
    }
#+END_SRC

** 使用“双重检查加锁”
   :PROPERTIES:
   :CUSTOM_ID: 使用双重检查加锁
   :END:

看代码：

#+BEGIN_SRC java
    public class Singleton {
        private volatile static Singleton singleton;

        public static Singleton getInstance() {
            //TODO
            if (singleton == null) {
                synchronized (Singleton.class) {
                    if (singleton == null) {
                        singleton = new Singleton();
                    }
                }
            }
            return singleton;
        }
    }
#+END_SRC

volatile
关键字确保，在实例变量被初始化时，多个进程可以正确的处理实例变量。

** 源码地址
   :PROPERTIES:
   :CUSTOM_ID: 源码地址
   :END:

https://github.com/nicehiro/Design-Patterns/tree/master/Singleton%20Pattern/src

** 感受
   :PROPERTIES:
   :CUSTOM_ID: 感受
   :END:

比原来理解的单件模式更深了一点，还需要实践啊。






