[[file:index.org][{back to main page}]]
#+TITLE: Linux Fork() 分析

#+DATE: 2016-12-07 08:05:54

昨天下午做了实验课，主要内容是熟悉使用 Linux 环境、Vim
操作、进程的=fork()=和=wait()=方法使用。实验倒是毫不费力的做完了，但是进程相当模糊。

#+BEGIN_HTML
  <!--more-->
#+END_HTML

** 进程 & fork
   :PROPERTIES:
   :CUSTOM_ID: 进程-fork
   :END:

参考：http://blog.csdn.net/jason314/article/details/5640969

进程是一个正在运行的程序的实例，某一个程序运行被加载到内存，这个正在运行的程序就是进程。

fork
函数，通过系统来创建一个和原来的进程几乎完全相同的进程。相当于是克隆了一个自己。

看看实验程序：

#+BEGIN_EXAMPLE
    #include "stdio.h"

    int main() {
            int i, j, k;

            if (i = fork()) {
                        j = wait();
                        printf("Parent Process!\n");
                        printf("i = %d, j = %d, k = %d\n", i, j);

            } else {
                        k = getpid();
                        printf("Child Process!\n");
                        printf("i = %d, k = %d\n", i, k);

            }

    }
#+END_EXAMPLE

函数执行结果：

[[http://oeoaak94a.bkt.clouddn.com/fork1.png]]

在执行=if (i = fork())=之前，只有一个进程在执行，但在这条语句之后，就有两个进程在执行了。这两个进程几乎完全相同，非常奇妙的一点不同之处在于：

#+BEGIN_QUOTE
  fork 被调用一次却有不同的返回值： - 父进程中，返回新创建的子进程的 ID
  - 子进程中，放回 0 - 如果出现错误，返回一个负值
#+END_QUOTE

上述程序用=i = fork()=来判断当前进程是否是子进程。

-  C 语言中，未初始化的全局变量 int 的值为：0
-  在父进程中，fork 返回的值是子进程 ID，即=i != fork()=
-  在子进程中，fork 返回的值是 0，即=i == fork()=

还可以定义一个变量来保存 fork 的结果值：

#+BEGIN_EXAMPLE
    pid_t fpid;
#+END_EXAMPLE

那么，为什么在父、子进程中 fork 的值会有不同呢？

摘自网友： > 其实就相当于链表，进程形成了链表，父进程的 fpid
指向子进程的进程 id，而子进程没有子进程，所以 fpid == 0

** 画进程数
   :PROPERTIES:
   :CUSTOM_ID: 画进程数
   :END:

先上例子：

#+BEGIN_EXAMPLE
    #include <stdio.h>

    int main() {
            int m, n, k;
            m = fork();
            printf("PID: %d\t", getpid());
            printf("The return value of fork(): %d\t\t", m);
            printf("hee\n");

            n = fork();
            printf("The return value of fork(): %d\t\t", n);
            printf("ha\n");

            k = fork();
            printf("PID: %d\t", getpid());
            printf("The return value of fork(): %d\t\t", k);
            printf("ho\n");

    }
#+END_EXAMPLE

看下结果：

[[http://oeoaak94a.bkt.clouddn.com/fork3.png]]

仔细分析下：

首先我们确定已经明白，pid：进程 id 号；fpid：fork() 返回值 -
先看前两个，第一个的 pid = 6264，fpid = 6265，而第二进程 pid =
6265，fpid = 0. 说明第二个进程是第一个进程的子进程。 -
同样这时可以找到的一对一对的进程是： pid = 6264，fpid = 6270 与 pid =
6270, fpid = 0 pid = 6225, fpid = 6269 与 pid = 6269, fpid = 0 pid =
6267, fpid = 6271 与 pid = 6271, fpid = 0 pid = 6266, fpid = 6268 与 pid
= 6268, fpid = 0 - 但是，如果你有懂前面说的 fork
的链表解释的话，你会发现有点问题，进程不能“连”起来了？！看似一对一对的进程井然有序，但是却不能连系起来？
> 想了好久，我终于意识到了：每个进程不是一成不变的！它的每个 fpid
都在随着程序执行过程中不断 fork
而不断变化的！因此，最后的结果只能是给我们得出一个最终状态的
fpid。并且不论 PID 被打印了几次，PID 的总数是不变的！

分析结束，插张进程树把：

[[http://oeoaak94a.bkt.clouddn.com/fork%E8%BF%9B%E7%A8%8B%E6%A0%91.png]]

** 感受
   :PROPERTIES:
   :CUSTOM_ID: 感受
   :END:

fork 还有一些特性没说，以后遇到再总结。






