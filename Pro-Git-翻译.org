#+HUGO_BASE_DIR: ~/Documents/blog/
#+hugo_section: notes
#+hugo_auto_set_lstmod: t

#+TITLE: Pro Git 翻译（未完）

#+DATE: 2018-03-17
#+OPTIONS: toc:nil

如果你想要只学一章就可以上手
Git，那么就学这章吧。这章内容包括了很多基本的命令，足够应对那些你需要花费很多时间用
Git 解决的问题。在本章结束时，应该掌握以下技能： -
配置并且初始化一个仓库； - 开始或是停止跟踪一个项目； -
暂存或是确认一个改变（changes）； - 让 Git
忽略某些文件或是某一类文件的改变； - 快速的撤销错误的操作； -
搜索你项目的历史提交，查看不同提交之间的改变； - 如何从远程仓库 push
或是 pull 一个项目。

** Getting a Git Repository
   :PROPERTIES:
   :CUSTOM_ID: getting-a-git-repository
   :END:

有两种方法获得一个 Git 仓库： - 将一个现有的项目下初始化为 Git 仓库； -
从远程服务器克隆（clone）一个 Git 仓库到本地。

*** 在已存在的目录下初始化一个 Git 仓库
    :PROPERTIES:
    :CUSTOM_ID: 在已存在的目录下初始化一个-git-仓库
    :END:

如果你打算在当前项目下用 Git
追踪已经存在的文件，只要在项目根目录下输入（终端）：

#+BEGIN_EXAMPLE
    $ git init
#+END_EXAMPLE

这个命令将会在项目根目录下创建一个新的二级子目录 ------
=.git=，这里面包含了一个 Git
项目的骨架文件。在这个时候，你项目中的所有文件都还没有被追踪。如果你想要开始对这些已经存在的项目开始版本控制，你得先对那些文件进行追踪，并且做一次最开始的提交操作。通过如下代码你就可以完成上诉操作：

#+BEGIN_EXAMPLE
    $ git add *.c
    $ git add README
    $ git commit -m 'initial project version'
#+END_EXAMPLE

执行完上诉操作，你的项目现在就已经成功被追踪，并且提交了第一次的确认。

*** 从远程仓库克隆
    :PROPERTIES:
    :CUSTOM_ID: 从远程仓库克隆
    :END:

如果你想要获取远程仓库的一份拷贝，比如是一个你非常想要搞的项目，你就可以使用
=git clone= 来完成。如果你熟悉使用其他版本控制系统（像是
Subversion），你将会发现我们的命令是 =clone= 而不（像它们）是
=checkout=。这是一个很重要的区别。在你执行 =git clone= 后，Git
得到的是几乎和服务器相同的数据，这个项目的每个历史记录中的每一个文件的每一个版本都被从服务器上拉了下来（pull
down）。所以，当你的服务器被毁掉时，你可以使用任何一个克隆来恢复服务器在被克隆时的数据。

从远程仓库克隆的方法：=git clone [url]=。 如果你要克隆 Ruby 的 Git
仓库的源代码，你可以这样：

#+BEGIN_EXAMPLE
    $ git clone git://github.com/schacon/grit.git
#+END_EXAMPLE

同样的，上诉命令将会产生一个文件夹名为 grit 的 Git 仓库，文件夹中有
=.git=
文件，并且有服务器上全部的文件。如果想要克隆这个项目到其他文件夹（不叫
grit），你可以执行以下操作：

#+BEGIN_EXAMPLE
    $ git clone git://github.com/schacon/grit.git mygrit
#+END_EXAMPLE

这个命令功能和前一个命令相同，不同的是它执行结果在本地的文件夹是叫
mygrit。

Git 有很多不同的传输协议可以供你使用。前面使用的是 =git://=
协议，你也可以使用 =http(s)://= 或是 使用 SSH 传输协议的
=user@server:/path.git=。

** 记录对仓库的更改
   :PROPERTIES:
   :CUSTOM_ID: 记录对仓库的更改
   :END:

你当前有一个良好的 Git
仓库和一堆已经检出的文件。这时候你编辑文件会对文件造成修改，你需要对这些改变进行确认来使它达到你想要记录的状态。

每一个文件在你的 Git
仓库下只有两种状态：被追踪的或是没有被追踪的。被追踪的文件在最新的快照里（snapshot），有未修改的（unmodified），已修改的（modified），暂存的（staged）三种状态。除了被追踪的文件剩下的文件都是未追踪的。所以，你第一次克隆一个
Git 项目时，所有的文件状态都是被追踪的和未修改的。

当你在修改文件的时候，Git
把它们看做是已修改的。，因为此时你上一次确认（commit）操作已经提交了上次的修改。这是你可以暂存这些修改了的文件然后进行确认操作，这些文件的状态就又变成了未修改的。见图：

[[]]

*** 检查当前文件的状态
    :PROPERTIES:
    :CUSTOM_ID: 检查当前文件的状态
    :END:

你可以使用 =git status=
去判定当前文件的状态。如果在刚刚克隆好的仓库下运行这个命令，你会看到如下所示：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) git status
    位于分支 master

    初始提交

    无文件要提交（创建/拷贝文件并使用 "git add" 建立跟踪）
#+END_EXAMPLE

这意味这你有一个干净的工作区，换句话说，这里没有被追踪的或是已修改的文件。Git
看不到那些没有被追踪的文件，即未追踪的文件不会被列出来。最后 Git
会给你列出分支目录，当前是 master 分支。不懂不必担心，之后会讲到的。

现在我们先添加一个 README 文件看看：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git status
    位于分支 master

    初始提交

    未跟踪的文件:
      （使用 "git add <文件>..." 以包含要提交的内容）

        README

    提交为空，但是存在尚未跟踪的文件（使用 "git add" 建立跟踪）
#+END_EXAMPLE

你可以看到你的新的 README 文件是未跟踪的。未跟踪的意思是，Git
看到了一个在当前的截图（snapshot）中没有的的文件；在后续的确认（commit）操作中不会提交这个文件。所以
Git 不会意外的添加那些你不希望跟踪的文件，比如说二进制文件。

*** 跟踪文件
    :PROPERTIES:
    :CUSTOM_ID: 跟踪文件
    :END:

可以使用 =git add= 去追踪一个文件。

#+BEGIN_EXAMPLE
    $ git add README
#+END_EXAMPLE

这是你可以再看一下当前状态：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git status
    位于分支 master

    初始提交

    要提交的变更：
      （使用 "git rm --cached <文件>..." 以取消暂存）

        新文件：   README
#+END_EXAMPLE

我们看到“要提交的变更”这句，说明我们的文件的状态是暂存。=git add=
后可以直接加文件名，如果加文件夹名，则整个文件夹内的文件都会被跟踪。

*** 暂存已修改的文件
    :PROPERTIES:
    :CUSTOM_ID: 暂存已修改的文件
    :END:

如果你修改了一个之前跟踪过的文件，比如说
=benchmarks.rb=，这是我们看下当前的状态是怎样的：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git status
    位于分支 master

    初始提交

    要提交的变更：
      （使用 "git rm --cached <文件>..." 以取消暂存）

        新文件：   README

    尚未暂存以备提交的变更：
      （使用 "git add <文件>..." 更新要提交的内容）
      （使用 "git checkout -- <文件>..." 丢弃工作区的改动）

        修改：     benchmarks.rb
#+END_EXAMPLE

=benchmarks.rb= 文件在已被修改但未保存，我们可以通过 =git add=
来暂存它：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git status
    位于分支 master

    初始提交

    要提交的变更：
      （使用 "git rm --cached <文件>..." 以取消暂存）

        新文件：   README
        新文件：   benchmarks.rb
#+END_EXAMPLE

注：这里中文版本的 Git 显示的提示内容不是很舒服，建议用英文版本的来看。

两个文件都暂存了。这时候，如果你想要再修改 =benchmarks.rb=
文件，我们在看下状态好了：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git status       
    位于分支 master

    初始提交

    要提交的变更：
      （使用 "git rm --cached <文件>..." 以取消暂存）

        新文件：   README
        新文件：   benchmarks.rb

    尚未暂存以备提交的变更：
      （使用 "git add <文件>..." 更新要提交的内容）
      （使用 "git checkout -- <文件>..." 丢弃工作区的改动）

        修改：     benchmarks.rb
#+END_EXAMPLE

在这个时候你提交确认，对应的 =benchmarks.rb= 文件是你上一次 =git add=
后的文件。也就是说，每次提交确认的文件是最近这次 =git add=
添加的文件。如果你需要提交最新的 =benchmarks.rb=，你需要再 =git add=
一次。

*** 可忽略的文件
    :PROPERTIES:
    :CUSTOM_ID: 可忽略的文件
    :END:

通常你会有一些二进制文件或是其他什么的不想让 Git
自动添加跟踪的文件（比如说编译 Java 产生的 .class 文件），也不想让 Git
每次都提醒你那个 .class 文件怎么还没被跟踪。这时，你可以创建一个
.gitignore
文件，在文件中列出匹配那些文件的表达式（pattern）。来看个例子：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ cat .gitignore
    *.[oa]
    *~
#+END_EXAMPLE

第一行告诉 Git 忽略所有已 .a 或是 .o 结尾的文件，第二行告诉 Git 忽略以 ~
结尾的文件（一般是各种编辑器的 swap
文件）。或许你还有一些日志文件，备份文件，自动生成的文档文件等都可以写入
.gitignore 来解决。

写在 .gitignore 中的匹配模式（pattern）规则如下： - 已 #
开头或是空行都会被忽略 - 可以使用标准的 glob 模式匹配 - 匹配模式后面加
=/= 指明被忽略的是文件夹 -
忽略指定模式以外的文件可以在匹配模式上取反，加 =!=

Glob 匹配就是 shell 所使用的简化了的正则表达式。 - * 匹配 0
个或更多的字符 - [abc] 匹配任何一个在方括号中的字符，这里指匹配 a 或 b
或 c - ? 只能匹配一个字符 -
在方括号里使用短横线将两个字符隔开，表明在这两个字符范围内都可以匹配（比如
=[0-9]= 表示 0 到 9 之间所有数字）

这里有一个例子：

#+BEGIN_EXAMPLE
    # 此为注释 – 将被 Git 忽略
    # 忽略所有 .a 结尾的文件
    *.a
    # 但 lib.a 除外
    !lib.a
    # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
    /TODO
    # 忽略 build/ 目录下的所有文件
    build/
    # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
    doc/*.txt
    # ignore all .txt files in the doc/ directory
    doc/**/*.txt
#+END_EXAMPLE

*** 查看已暂存和未暂存的改变
    :PROPERTIES:
    :CUSTOM_ID: 查看已暂存和未暂存的改变
    :END:

如果你觉得 =git status=
不太明确要表达什么，你想要知道到底当前的提交改变了什么而不是仅仅知道什么被改变了，你可以使用
=git diff= 这个命令。待会将会详细解释
=git diff=，你现在可以先使用它并回答两个问题： -
当前的更新那些还没有暂存？ - 当前那哪些更新已经暂存等待下一次提交确认？
尽管 =git status= 已经很好的回答了这些问题，但 =git diff=
会以文件补丁的方式给我们显示到底哪些行被添加或是删除了。

先编辑并暂存 README 文件，然后编辑 benchmarks 文件不暂存它。然后运行
status 命令，可以看到：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git status
    位于分支 master

    初始提交

    要提交的变更：
      （使用 "git rm --cached <文件>..." 以取消暂存）

        新文件：   README

    尚未暂存以备提交的变更：
      （使用 "git add <文件>..." 更新要提交的内容）
      （使用 "git checkout -- <文件>..." 丢弃工作区的改动）

        修改：     benchmarks.rb
#+END_EXAMPLE

看看你到底改变了哪些东西还没有暂存，使用 diff 命令：

#+BEGIN_EXAMPLE
    diff --git a/benchmarks.rb b/benchmarks.rb
    index 90e5c42..6249b42 100644
    --- a/benchmarks.rb
    +++ b/benchmarks.rb
    @@ -1 +1,3 @@
     First Initial
    +
    +Second change
    (END)
#+END_EXAMPLE

该命令匹配你当前工作区和暂存区的文件，然后显示出你到底改变了那些地方。

如果要查看已经暂存的文件和上次提交确认的快照之间的差别，可以使用
=git diff --cached=。（在 Git 版本 1.6.1 以上，你也可以使用
=git diff --staged=，更容易记一些）。看看效果先：

#+BEGIN_EXAMPLE
    diff --git a/README b/README
    new file mode 100644
    index 0000000..5b79f79
    --- /dev/null
    +++ b/README
    @@ -0,0 +1 @@
    +This is a simple README.
    diff --git a/benchmarks.rb b/benchmarks.rb
    new file mode 100644
    index 0000000..90e5c42
    --- /dev/null
    +++ b/benchmarks.rb
    @@ -0,0 +1 @@
    +First Initial
#+END_EXAMPLE

这个命令比较的是你工作区的文件和你暂存区的文件。运行结果会告诉我们你在工作区做了那些改变却还没有暂存。
如果你想要知道已经暂存的、将要提交到下一次 commit 的内容，你可以使用
=git diff --cached=。（ Git 版本 1.6.1 以及这之后的版本中，你还可以使用
=git diff --staged=，或许这更容易理解一些吧。）这个命令告诉我们你暂存的改变和下次
commit 有哪些区别：

#+BEGIN_EXAMPLE
    diff --git a/README b/README
    new file mode 100644
    index 0000000..5b79f79
    --- /dev/null
    +++ b/README
    @@ -0,0 +1 @@
    +This is a simple README.
    diff --git a/benchmarks.rb b/benchmarks.rb
    new file mode 100644
    index 0000000..6249b42
    --- /dev/null
    +++ b/benchmarks.rb
    @@ -0,0 +1,3 @@
    +First Initial
    +
    +Second change
#+END_EXAMPLE

需要指出，=git diff= 本身只显示上次以来未暂存的改变，而不是显示上次
commit
以来的改变。这看起来有些困惑。如果你已经暂存了所有的改变，那么现在你的
=git diff= 是没有内容的。 再举个例子，如果你先暂存了 benchmarks.rb
文件然后又修改了它，这时，你可以用 =git diff=
去查看暂存的和未暂存的文件的区别：

#+BEGIN_EXAMPLE
    位于分支 master

    初始提交

    要提交的变更：
      （使用 "git rm --cached <文件>..." 以取消暂存）

        新文件：   README
        新文件：   benchmarks.rb

    尚未暂存以备提交的变更：
      （使用 "git add <文件>..." 更新要提交的内容）
      （使用 "git checkout -- <文件>..." 丢弃工作区的改动）

        修改：     benchmarks.rb
#+END_EXAMPLE

现在试试 =git diff= 吧：

#+BEGIN_EXAMPLE
    diff --git a/benchmarks.rb b/benchmarks.rb
    index 6249b42..f539a39 100644
    --- a/benchmarks.rb
    +++ b/benchmarks.rb
    @@ -1,3 +1,5 @@
     First Initial

     Second change
    +
    +Third change
    (END)
#+END_EXAMPLE

然后再用 =git diff --cached= 来看看你上次暂存的：

#+BEGIN_EXAMPLE
    diff --git a/README b/README
    new file mode 100644
    index 0000000..5b79f79
    --- /dev/null
    +++ b/README
    @@ -0,0 +1 @@
    +This is a simple README.
    diff --git a/benchmarks.rb b/benchmarks.rb
    new file mode 100644
    index 0000000..6249b42
    --- /dev/null
    +++ b/benchmarks.rb
    @@ -0,0 +1,3 @@
    +First Initial
    +
    +Second change
    (END)
#+END_EXAMPLE

（总之，=git diff= 指出修改过的文件和暂存的文件的改变。）

*** 确认（commit）你的改变
    :PROPERTIES:
    :CUSTOM_ID: 确认commit你的改变
    :END:

现在你暂存区的文件已经准备好了，现在你可以 commit 他们。
请一定确认，如果有任何文件没有暂存------你新创建的、你修改过却没有
=git add= 过的，都不要进行 commit
步骤！这些修改过的文件还是保存在你的硬盘上。

你可以运行 =git status=
查看你文件的状态，它会告诉你所有改变都已经暂存过了。你就可以放心的使用
=git commit= commit 你的文件。

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git status
    位于分支 master

    初始提交

    要提交的变更：
      （使用 "git rm --cached <文件>..." 以取消暂存）

        新文件：   README
        新文件：   benchmarks.rb

    ➜  progit git:(master) ✗ git commit
#+END_EXAMPLE

这样做会调用你的编辑器来完成 commit
操作。（调用什么编辑器是又你系统的编辑器环境变量 =$EDITOR=
来决定，通常是 vim 或者
emacs）。当然你也可以配置任何你想要使用的编辑器来完成
commit：=git config --global core.editor=）。
编辑器将会显示以下内容（以下使用 vim 编辑器）：

#+BEGIN_EXAMPLE
    GNU nano 2.7.1        文件： /home/hiro/Documents/progit/.git/COMMIT_EDITMSG                 


    # 请为您的变更输入提交说明。以 '#' 开始的行将被忽略，而一个空的提交
    # 说明将会终止提交。
    # 位于分支 master
    #
    # 初始提交
    #
    # 要提交的变更：
    #       新文件：   README
    #       新文件：   benchmarks.rb
    #
                                          [ 已读取11 行 ]
    ^G 求助        ^O Write Out   ^W 搜索        ^K 剪切文字    ^J 对齐        ^C 游标位置
    ^X 离开        ^R 读档        ^\ 替换        ^U Uncut Text  ^T 拼写检查    ^_ 跳行
#+END_EXAMPLE

可以看出，默认的 commit 操作内容包含了最近一次的 =git status=
的输出作为住食行，以及顶部的一个空行。当然你可以移除这些默认的 commit
信息然后编辑自己想写的；如果你记性不好也可以保留它们来帮助你记住这次提交你到底
commit 了哪些文件。（如果你想要更详细的修改信息，你可以添加 =-v= 在
=git diff= 之后。这样，就可以连同 diff 信息一并写入 commit
中。）当你退出编辑器时，Git 会使用你填写的 commit 消息创建一次
commit（commit 时会丢去注释和 diff 信息）。

当然，你也可以直接使用 =git commit= 命令添加 =-m= 选项完成 commit 操作：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git commit -m "first commit"
    [master（根提交） b9f7323] first commit
     2 files changed, 8 insertions(+)
     create mode 100644 README
     create mode 100644 benchmarks.rb
#+END_EXAMPLE

现在，你已经创建了你的第一次 commit。这次 commit
的输出会给你一些附加信息：当前提交是在哪个分支（master），本次提交的
SHA-1
校验和是什么（b9f7323），有多少文件被改变，有多少行被添加或是被减少的信息。
记住你的 commit
记录的是你当前暂存区的快照。任何你没有暂存的文件在此时的状态都是未修改的；你可以在进行一次
commit 把它们提交。每当你提交一个
commit，你就相当于记录了当前工程的一个快照，，你可以回到那个状态，或是之后进行比较。

*** 跳过使用暂存区
    :PROPERTIES:
    :CUSTOM_ID: 跳过使用暂存区
    :END:

尽管使用暂存区可以让你精心准备你要提交的
commit，但有些时候使用暂存区有些繁琐。如果你想要跳过使用暂存区，Git
提供了一个简单的快捷方式。在 =git commit= 命令后添加 =-a= 参数，可以使
Git 在 commit 之前自动暂存所有已经被 Git 跟踪过的文件，让你跳过
=git add= 那个步骤：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git status
    位于分支 master
    尚未暂存以备提交的变更：
      （使用 "git add <文件>..." 更新要提交的内容）
      （使用 "git checkout -- <文件>..." 丢弃工作区的改动）

        修改：     benchmarks.rb

    修改尚未加入提交（使用 "git add" 和/或 "git commit -a"）
    ➜  progit git:(master) ✗ git commit -a -m 'modefied the file again'
    [master 06cb46b] modefied the file again
     1 file changed, 2 insertions(+)
#+END_EXAMPLE

看到了吧，你可以不用使用 =git add= 这个命令直接就进行 commit 了。

*** 删除文件
    :PROPERTIES:
    :CUSTOM_ID: 删除文件
    :END:

在 Git
中移除一个文件，你需要先从你跟踪的文件里面移除它（确切的说，是从暂存区中移除）然后再提交
commit。命令 =git rm=
可以实现上诉操作，并且在同时把你工作区中的哪个文件也一并移除了，所以下次你不再会看到未跟踪的文件在你的工作区了。
如果你仅仅是简单的从你的工程目录把那个文件移除了，他在 =git status=
上将会被显示到“尚未暂存以备提交的变更：”（也就是没有暂存）的区域：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git status
    位于分支 master
    要提交的变更：
      （使用 "git reset HEAD <文件>..." 以取消暂存）

        新文件：   test

    尚未暂存以备提交的变更：
      （使用 "git add/rm <文件>..." 更新要提交的内容）
      （使用 "git checkout -- <文件>..." 丢弃工作区的改动）

        删除：     test
#+END_EXAMPLE

这时，运行 =git rm=，将会暂存文件的移除操作：

#+BEGIN_EXAMPLE
    ➜  progit git:(master) git rm test
    rm 'test'
    ➜  progit git:(master) ✗ git status
    位于分支 master
    要提交的变更：
      （使用 "git reset HEAD <文件>..." 以取消暂存）

        删除：     test
#+END_EXAMPLE

下次你再提交时，这个文件不会存在并不在被 Git
跟踪。如果在删除之前就修改过文件并且已经加入到了暂存区，你需要加 =-f=
选项来强制删除。这是一种安全特性，用于防止意外删除那些还未存入暂存区的数据，而这样的删除的无法恢复的。

#+BEGIN_EXAMPLE
    ➜  progit git:(master) ✗ git rm test
    error: 下列文件索引中有变更
        test
    （使用 --cached 保留本地文件，或用 -f 强制删除）
#+END_EXAMPLE

或许你还想要做这样的事，在本地保存该文件而不把他添加到暂存区中。换句话说，你或许想要只把那个文件保存到你的硬盘上而不想被
Git 追踪。如果你忘记在你的 =.gitignore=
文件中添加某些文件的名称，而又不小心把很大的日志文件和一堆 .a
文件都添加到了你的暂存区，你可以使用 =--cached= 这个选项：

#+BEGIN_EXAMPLE
    git rm --cached readme.txt
#+END_EXAMPLE

你可以添加文件名、目录名和 glob 语法在 =git rm=
命令后面。这意味着你可以写这样的命令：

#+BEGIN_EXAMPLE
    git rm log/\*.log
#+END_EXAMPLE

你会发现在 * 的前面有  的出现。这是必须有的。因为 Git
用自己的文件名字扩展来替换你 shell 的文件名字扩展。这个命令将会移除在
log 文件夹下所有以 =.log= 为扩展名的文件。当然，你也可以这样做：

#+BEGIN_EXAMPLE
    git rm \*~
#+END_EXAMPLE

这个命令将会移除当前目录下所有以 =~= 结尾的文件。

*** 移动文件
    :PROPERTIES:
    :CUSTOM_ID: 移动文件
    :END:

不像其他 VCS 系统一样，Git 不会显示的跟踪文件的移动。当你重命名一个在
Git 追踪下的文件时，Git
并不会存储一些数据来告诉你到底你重命名了哪个文件。但是 Git
非常聪明，它可以推断出你改了哪个文件------在不久之后就会谈到。

当你看到 Git 的 mv
命令时一定会很困惑。如果你想要重命名一个文件，你可以这样做：

#+BEGIN_EXAMPLE
    git mv file_from file_to
#+END_EXAMPLE

这个命令绝对达到了效果。事实上，如果你运行上诉命令之后再看一下
status，你将会发现其实那个文件的状态已经被置为了重命名了。

#+BEGIN_EXAMPLE
    ➜  progit git:(master) git mv README README.txt
    ➜  progit git:(master) ✗ git status
    位于分支 master
    要提交的变更：
      （使用 "git reset HEAD <文件>..." 以取消暂存）

        重命名：   README -> README.txt
#+END_EXAMPLE

当然，这个命令相当于运行一下的命令：

#+BEGIN_EXAMPLE
    mv README README.txt
    git rm README
    git add README.txt
#+END_EXAMPLE

Git
会知道你运行的那个命令是一个重命名操作，所以它不关心你是否是真的重命名了那个文件还是使用了
mv 命令。唯一的区别 mv 只有一条命令，而重命名有三条命令，使用 mv
是一个很便捷的操作。有时候你会使用你喜欢的工具去重命名一个文件，不要忘记在最后提交
commit 前需要使用 add/rm 操作。

** 查看提交历史
   :PROPERTIES:
   :CUSTOM_ID: 查看提交历史
   :END:
当你提交了多个 commit，或者是你 =git clone= 的仓库中有多个 commit，这时候你想去回头看看这个仓库究竟做了哪些提交，你可以考虑使用 =git log= 命令。

用一个非常简单的例子讲解这个方法，例子仓库可以这样获取：
#+BEGIN_SRC sh
git clone git://github.com/schacon/simplegit-progit.git
#+END_SRC

** 感受
   :PROPERTIES:
   :CUSTOM_ID: 感受
   :END:






