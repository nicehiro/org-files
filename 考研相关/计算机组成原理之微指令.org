[[file:index.org][{back to main page}]]
#+TITLE: 计算机组成原理之微指令

#+DATE: 2016-10-19 13:54:35

平时不好好学习，上课不认真听课的后果就是课程设计让你忙到要死......

不过讲真，就算你认真听课也是没用的，因为题目就是那么变态。

原来打算直接在网上搞一份答案抄完就完事，可没想到发生了一系列不愉快的事情，让我不得不打起精神抱起实验书在考试周啃起了微指令。从来没有想到过我可以搞到这么底层的东西，现如今，该经历的还是要经历的。躲是躲不了的了，那就干吧！

#+BEGIN_HTML
  <!--more-->
#+END_HTML

课程设计的要求是这样的：

#+BEGIN_QUOTE
  深入了解计算机各种指令的执行过程，以及控制器的组成，指令系统微程序设计的具体知识，进一步理解和掌握动态微程序设计的概念；完成微程序控制的特定功能计算机的指令系统设计和调试。
#+END_QUOTE

这种涉及到底层的东西就这么变态。

** 动手做
   :PROPERTIES:
   :CUSTOM_ID: 动手做
   :END:

第一个题目：

#+BEGIN_QUOTE
  把用绝对地址表示的内存单元A中的内容与内存单元B中的内容相加，结果存于内存单元C中。
  指令格式：D4××，ADDR1，ADDR2，ADDR3 四字指令（控存入口100H） 功能：
  [ADDR3] = [ADDR1] + [ADDR2]
#+END_QUOTE

如果用高级语言，只要用‘ + '就可以搞定；就算你用汇编语言，也就一个指令
add(adc)
ax,bx，可是你要真正用机器语言实现，起码需要七条语句，每个语句56位，慢慢搞吧。

*** 先了解一下......
    :PROPERTIES:
    :CUSTOM_ID: 先了解一下
    :END:

解决此问题需要你必备几个基础技能，也就是基础知识点，基础属性不好你怎么打怪？

-  TEC-2机的控制器部件，主要由1片AM2910实现的微程序定序器、7片6116芯片（RAM存储器，8x2048
   容量）与两片8x2048容量的2716
   ROM芯片组成的控存、56位的微指令寄存器，以及16位的指令寄存器和2片2716芯片组成的微控存地址映射部件等组成。
   它的主要功能是形成下一条微指令的地址，保证程序可以正常运行。
-  程序计数器 PC 即 通用寄存器 R5，指令寄存器 IP 即 通用寄存器 R6。
-  会看简明操作卡。
-  Am2901 A 四位运算器逻辑示意图： 解释一下： ALU可以接收进位信号 Cn 。

可以接收外部送入的4位数据 D3-0，并输入4位的数据
Y3-0。Y3-0可以是通用寄存器上A 端口上的输出或 ALU 的运算结果 F。

ALU 的两个输入端 R 和 S 分别可以接收 D 输入、A 端口或逻辑0数据，和 A
端口、B 端口、Q寄存器或逻辑0数据。

-  A 端口只可以输出不可以输入，B 端口既可以输入也可以输出。
-  微指令寄存器 PLR 由7片8位的寄存器芯片（6片 LS374 和一片 LS273
   ）组成，用于存放当前微指令的内容。
-  微指令格式与其所代表的意义：

B55 - B46 ：10位微码是下地址字段；

B45 - B44 ：备用；

B43 - B40 为 CI3 - 0，用于给出 AM2910 芯片的16位命令码的编号；

B39 - B37、B36 分别是3位的 SCC 和一位的 SC，用于保证微指令的条件转移等；

提供给运算器部件的控制信号一共有26位，分别是：

A 口地址，B 口地址，SA，SB；

控制标志寄存器写入的 SST、最低位进位控制 SCI，移位信号形成的 SSH
共七位；

/MIO、REQ 和 /WE 用于控制内存的读写，外设接口的读写，以及微码的装入。
### demo1

#+BEGIN_EXAMPLE
    PC -> AR,PC+1 -> PC             0000 0E00 A0B5 5402
    0000 0000 0000 1110 0000 0000 1010 0000 1011 0101 0101 0100 0000 0010
    MEM -> AR                       0000 0E00 10F0 0002
    0000 0000 0000 1110 0000 0000 0001 0000 1111 0000 0000 0000 0000 0010
    MEM -> Q                        0000 0E00 00F0 0000
    0000 0000 0000 1110 0000 0000 0000 0000 1111 0000 0000 0000 0000 0000
    PC -> AR,PC+1 -> PC             0000 0E00 A0B5 5402
    0000 0000 0000 1110 0000 0000 1010 0000 1011 0101 0101 0100 0000 0010
    MEM -> AR                       0000 0E00 10F0 0002
    0000 0000 0000 1110 0000 0000 0001 0000 1111 0000 0000 0000 0000 0010
    MEM+Q -> Q                      0000 0E01 00E0 0000
    0000 0000 0000 1110 0000 0001 0000 0000 1110 0000 0000 0000 0000 0000
    IP+1 -> AR                      0000 0E00 9030 6402
    0000 0000 0000 1110 0000 0000 1001 0000 0011 0000 0110 0100 0000 0010
    MEM -> AR                       0000 0E00 10F0 0002
    0000 0000 0000 1110 0000 0000 0001 0000 1111 0000 0000 0000 0000 0010
    Q -> MEM,CC# = 0                0029 0300 1020 0010
    0010 1001 0000 0011 0000 0000 0001 0000 0010 0000 0000 0000 0001 0000
#+END_EXAMPLE

一共使用9条微指令实现 addr1 = addr1 +
addr2，这里针对第一条指令做出说明，其余指令大同小异： PC -> AR,PC+1 ->
PC

#+BEGIN_QUOTE
  拿出操作卡，我们来认真比对：
#+END_QUOTE

#+BEGIN_QUOTE
  前十位为：0000 0000 00，这是下地址，如果转移的话和这个有关；
#+END_QUOTE

#+BEGIN_QUOTE
  接下来是：00，为备用字段；
#+END_QUOTE

#+BEGIN_QUOTE
  下来是：1110，对应 CI3 - 0，即14H，表示程序不发生转移，顺序执行；
#+END_QUOTE

#+BEGIN_QUOTE
  下来是：0000，对应操作卡是 SCC=000，SC=0，CC#=1，不发生转移；
#+END_QUOTE

#+BEGIN_QUOTE
  下来是：0000，对应 SST=000，即标志寄存器不发生变化；
#+END_QUOTE

#+BEGIN_QUOTE
  下来是：1010，对应 MIO#=1，MI8 - 6=010
#+END_QUOTE

#+BEGIN_QUOTE
  ------------0000，对应 REQ=0， MI5 -3=000
#+END_QUOTE

#+BEGIN_QUOTE
  ------------1011，对应 WE#=1，MI2 - 0=011；
#+END_QUOTE

#+BEGIN_QUOTE
  ------------上述三条指令 MIO#、REQ、WE#组成101，控制读写，此时为不操作
#+END_QUOTE

#+BEGIN_QUOTE
  ------------MI8 - 6=010，寄存器结果输出为 A 端口，并将计算结果 F 送到
  B 端口
#+END_QUOTE

#+BEGIN_QUOTE
  ------------MI5 - 3=000，R+S，加法运算
#+END_QUOTE

#+BEGIN_QUOTE
  ------------MI2 - 0=011，两个操作数为 B 端口内容和数 0
#+END_QUOTE

#+BEGIN_QUOTE
  下来是：0101，对应 A 端口，即 A 端口为寄存器 R5
#+END_QUOTE

#+BEGIN_QUOTE
  下来是：0101，对应 B 端口，即 B 端口为寄存器 R5
#+END_QUOTE

#+BEGIN_QUOTE
  下来是：0100，对应 SCi=01，SSH=00，即进位 Cin=1，并且不发生移位
#+END_QUOTE

#+BEGIN_QUOTE
  下来是：0000 0010，对应 SA=0，SB=0，表示由 A，B口决定
  A，B端口内容，且运算器计算出的内容送到 AR 地址寄存器；
#+END_QUOTE

上面解释完第一条微指令，其他的也大体相同，我就不剥夺你们发掘知识的快感了......

** 吐槽
   :PROPERTIES:
   :CUSTOM_ID: 吐槽
   :END:

老师说：怎么有九条指令啊，我只需要用7条就可以出来了，回去再改改，你是不是没动脑子啊......

我开心的笑了。

遇到这么好的老师你还能说什么。

强颜欢笑 手动笑脸 QQ式微笑

不过不怕不怕，我们有Google！

然而令我气愤的是Google出来的答案有10条的，有9条的，有8条的，可是，可是，偏偏，没有7条的！！！

我就 * 了狗了！！！

最后只能找了个大腿抱了，原谅我都智商。

** 其他答案
   :PROPERTIES:
   :CUSTOM_ID: 其他答案
   :END:

迷之十条微指令

#+BEGIN_EXAMPLE
    100：PC→AR，PC+1→PC：      0000   0E00   A0B5   5402
    101：MEM→AR：            0000   0E00   10F0   0002
    102：MEM→Q：             0000    0E00   00F0   0000
    103：PC→AR：             0000    0E00   90B0   5002
    104：MEM→AR：            0000    0E00   10F0   0002
    105：MEM+Q→Q：           0000    0E01   00E0   0000
    106：PC-1→AR：           0000   0E00   91B0   5402
    107: PC+1→PC：           0000   0E00   B0B0   5400
    108: MEM→AR：            0000   0E00   10F0   0002
    109：Q→MEM，CC#=0，3#：     0029   0300   1020   0010
#+END_EXAMPLE

迷之八条微指令

#+BEGIN_EXAMPLE
    100：PC+1→AR： 0000 0E00 90B5 5402
    101：MEM→AR： 0000 0E00 10F0 0002
    102：MEM→Q： 0000 0E00 00F0 0000
    103：PC→AR，PC+1→PC： 0000 0E00 A0B5 5402
    104：MEM→AR： 0000 0E00 10F0 0002
    105：PC+1→PC: 0000 0E00 A0B5 5400
    106：MEM+Q→Q： 0000 0E01 00E0 0000
    107：Q→MEM，CC#=0： 0029 0300 1020 0010
#+END_EXAMPLE

最佳设计

#+BEGIN_EXAMPLE
    PC -> AR,PC+1 -> PC     0000 0E00 A0B5 5402
    ;将第一个数的地址送到AR
    MEM -> AR，MEM -> IP     0000 0E00 30F0 6002
    ;将第一个数的地址送到MEM
    MEM -> Q            0000 0E00 00F0 0000 ;读取到的指令送Q寄存器
    PC -> AR,PC+1 -> PC     0000 0E00 A0B5 5402
    MEM -> AR           0000 0E00 10F0 0002
    ;d第二个数的地址送到MEM
    MEM + Q -> IP,IP -> AR      0000 0E00 20E6 6002 ;两数相加结果送Q寄存器
    IP -> MEM,CC# = 0       0029 0300 1030 6090 ;结果写到第一个内存
#+END_EXAMPLE

** 结尾
   :PROPERTIES:
   :CUSTOM_ID: 结尾
   :END:

做什么东西都不难，只要你真正做进去了。BTW，老师，整个理工我只服你......






