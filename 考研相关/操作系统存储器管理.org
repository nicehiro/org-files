[[file:index.org][{back to main page}]]
#+TITLE: 操作系统存储器管理
#+DATE: 2016-12-30 15:36:50
#+OPTIONS: toc:nil

#+BEGIN_CENTER
Nov 30, 2016
#+END_CENTER

考前复习操作系统，真的被它吸引了。搞懂了操作系统真的可以把以前很多知识结合起来的！

本文参考了一篇我自以为很全面的博客，我写这个只是想把我的理解写下来，
参考：http://www.cnblogs.com/leesf456/p/5616041.html

#+TOC: headlines 2

#+BEGIN_HTML
  <!--more-->
#+END_HTML

** 存储器的层次结构
   :PROPERTIES:
   :CUSTOM_ID: 存储器的层次结构
   :END:

*** 主存储器
    :PROPERTIES:
    :CUSTOM_ID: 主存储器
    :END:

用于保存进程运行时的程序和数据。CPU
的控制部件只能从主存储器中取得指令和数据，数据可以从主存储器中装到寄存器或是从寄存器中存到主存储器中。

这里的主存储器也叫主存，我特意查了下它与内存的区别。内存也叫内部存储器，早期的计算机是没有其他辅助存储器（高速缓冲存储器），所以传统上主存也就是内存，一个指的是作用（主），另一个说的是位置（内），说法不同而已。

*** 寄存器
    :PROPERTIES:
    :CUSTOM_ID: 寄存器
    :END:

访问速度最快，价格昂贵，主要用于存放操作数等。

*** 高速缓存
    :PROPERTIES:
    :CUSTOM_ID: 高速缓存
    :END:

容量大于寄存器，小于主存，但访问速度高于主存，也叫辅助存储器。每次使用的时候，会将使用的进程的程序和数据临时复制到高速缓冲，当
CPU
执行时，会先访问高速缓冲中是否有，如有，直接取出使用，否则，从主存中读取信息。

*** 磁盘缓存
    :PROPERTIES:
    :CUSTOM_ID: 磁盘缓存
    :END:

磁盘 IO
的速度远低于主存，因此可以将频繁使用的一部分磁盘数据和信息暂时保存在磁盘缓存中。注意，它本身并不是一种存储介质，是利用主存的存储空间来暂存的。

** 程序的装入和链接
   :PROPERTIES:
   :CUSTOM_ID: 程序的装入和链接
   :END:

程序要可以运行，首先要为程序创建进程，而创建进程的第一件事就是将程序和数据装入内存。将一个源程序编程一个可执行程序，编译过
C 语言的大家都知道，先编译，在链接，最后才能装入到主存中。

如果了解汇编的编译方式： -
编译：有编译程序将源代码编译成若干个目标模块，在汇编中就会编译成=.obj=文件；
-
链接：有链接程序将编译后生成的目标模块和所需的库函数链接在一起，形成一个完整的装入模块，在汇编中就是使用=link=链接生成的目标文件；
- 装入，由装入程序将装入模块装入内存。

*** 程序的装入方式
    :PROPERTIES:
    :CUSTOM_ID: 程序的装入方式
    :END:

在装入程序将装入模块装入内存时，有三种方式：绝对装入方式，可重定位装入方式，动态装入方式。
-
绝对装入方式：就是说我在编译的时候程序就已经知道将来编译好了装在内存中哪个位置，那么在程序编译好后，就按照模块中的地址装入，不需要逻辑地址与实际地址的转换；
-
可重定位装入方式：编译的时候不知道程序该装到内存的那个位置去，于是在装入的时候装入程序根据内存的当前情况，将装入模块装入到内存的合适位置。
-
动态运行时装入方式：并不立即把装入模块中的物理地址转换为绝对地址，而是把这种地址转换推迟到程序真正运行的时候。

*** 程序的链接
    :PROPERTIES:
    :CUSTOM_ID: 程序的链接
    :END:

根据链接时间的不同，可以把链接分为静态链接，装入时动态链接，运行时动态链接。
-
静态链接：程序运行前，先将各个模块及它们需要的库函数链接起来，中规中矩一步一步来的；
-
装入时动态链接：在得到编译后的一组目标模块之后，先不进行链接，而是在装入内存的时候。边装入边链接；
- 运行时动态链接：在程序执行时需要某个模块时，才对他进行链接

让我想起了刚学的 Android。

Android 5.1
开始运用的是在安装过程中进行编译，用的是装入时动态链接方式，所以我们在
5.1 的系统上会感觉到安装很慢；而在 7.0
时候采用了混合编译的方式，即在安装过程中编译一部分（装入是动态链接），在程序运行时也会对需要使用的模块进行编译（运行时动态链接），所以
7.0 系统安装东西会很快。

** 连续分配方式
   :PROPERTIES:
   :CUSTOM_ID: 连续分配方式
   :END:

装入程序将装入模块装入到内存中时，如何为装入模块分配内存呢？连续分配方式是指为一个用户程序分配一个连续的内存空间。有单一连续分配，固定连续分配，动态连续分配，动态重定位分区分配。

*** 单一连续分配
    :PROPERTIES:
    :CUSTOM_ID: 单一连续分配
    :END:

将内存分为用户区和系统区。低地址是系统区，放操作系统，用户区由低地址向高地址分配。

*** 固定分区分配
    :PROPERTIES:
    :CUSTOM_ID: 固定分区分配
    :END:

-  将内存分为固定分区，大小相等。但如果程序太小，就会浪费；如果程序太大，就无法运行。
-  将内存划分为多个大小不同的小分区，按照从小到大的顺序排列。分配时，会从分区中检索出一个满足要求的并且尚未分配的分区，将它分配给程序。

*** 动态分区分配
    :PROPERTIES:
    :CUSTOM_ID: 动态分区分配
    :END:

根据实际需要，动态的为某个程序分配空间。

所用到的数据结构：空闲分区链表 - 一个向前指针，指向前一个空闲分区的地址
- 一个向后指针，指向后一个空闲分区的地址 -
中间便是表示该空闲分区的大小所用

分配算法如下： -
首次适应算法：要求空闲分区链表以*地址*递增的次序链接。当每次分配空闲空间的时候从链表首部开始，找到第一个合适的空间便直接分配；
-
循环首次适应算法：由首次适应算法而来，只是每次分配时，不是中链表首部开始查找，而是从上次查找结束的位置开始查找；
-
最佳适应算法：要求空闲分区以空间大小递增的次序链接。这样，第一次找到的满足要求的空闲区必然是最佳的；
-
快速适应算法：将空闲分区容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这些，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针

*** 回收内存
    :PROPERTIES:
    :CUSTOM_ID: 回收内存
    :END:

当进程运行完毕释放内存时，系统会根据回收区的地址，回收内存。 -
回收分区与插入点前一个分区邻接：修改前一分区的大小 -
回收分区与插入点后一个分区邻接：修改后一分区的大小 -
回收分区既与插入点前一个分区邻接，也和插入点后一个分区邻接：合并三个分区
- 回收分区孤立：新建一个空闲分区好了

*** 可重定位分区分配
    :PROPERTIES:
    :CUSTOM_ID: 可重定位分区分配
    :END:

如果系统中有若干个连续的空闲空间，但他们都不够一个程序所需要的空间大小，但它们空闲内存加起来可以满足那个程序，那么就移动那些空闲空间，合并成一个大的空闲空间来让那个进程使用。

** 分页存储管理方式
   :PROPERTIES:
   :CUSTOM_ID: 分页存储管理方式
   :END:

为了让那些空闲空间碎片得到利用，前面用了可重定位分区分配方式来分配内存，那是从分配内存的角度解决问题的。而如果我们的进程可以分散的在不同的内存中执行时，就不需要上述的分配方式了。

*** 页面与页表
    :PROPERTIES:
    :CUSTOM_ID: 页面与页表
    :END:

分页存储管理将一个进程的逻辑地址空间分为若干个大小相等的片，称为页面或页，并为每页编码，从
0
开始。相应的，把内存空间分成和页面相同大小的若干个存储块，称为物理块，也同样编号。

为了保证在内存中找到每个页面对应的物理块，系统为每个进程建立了一张页面映射表，即页表。页表实现了从页号到物理块号的地址映像。

每次访问一个数据时，都会访问两次内存。第一次是访问内存中的页表，找到指定页的物理块号，将物理块号与页内记录的偏移地址结合形成物理地址；第二次访问根据物理地址来访问数据。

*** 多级页表
    :PROPERTIES:
    :CUSTOM_ID: 多级页表
    :END:

** 分段存储管理方式
   :PROPERTIES:
   :CUSTOM_ID: 分段存储管理方式
   :END:

在分段管理中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，每个段都有自己的功能，自己的名字，每个段都是由
0 开始编址，并采用一段连续的地址空间，其逻辑地址是由段号和段内地址构成。

是了，和汇编结合起来了！

从固定分区到动态分区分配，再到分页存储管理方式，都是在提高内存的利用率；而分段存储方式是为了其他的要求：
- 方便编程，汇编用到； -
信息共享，相当于是一个函数，一个功能的段在一个分区，其他需要此段功能的进程如需要可以直接调用；
- 动态链接：需要的时候再链接。

同样访问一个数据时，第一次访问根据段号获得基址（段号的物理地址），再次访问获得段内地址，结合基址与段内地址可以得到该数据的物理地址，然后就可以访问到了。

*** 分页管理方式和分段管理方式的区别
    :PROPERTIES:
    :CUSTOM_ID: 分页管理方式和分段管理方式的区别
    :END:

它们很相似，都是采取离散分配的方式，都需要通过地址映射基址来实现地址的转换；二者有区别如下：
-
分页是为了实现离散分配方式，提高内存利用率。分页只是由于系统管理的需要而不是用户的耍要，而分段的目的就是为了满足用户的需要；也就是说，分页只是为了提高内存利用率，而分段则是考虑可以多次使用，方便编程；
-
页的大小固定由系统决定，系统把逻辑地址分为页号和页面地址两个部分，有机器硬件实现的，一个系统中只存在一种大小的页面；而段的长度不确定，有用户自己编写的程序决定；
-
分页的地址空间是一维的，而分段的地址空间是二维的，即分页的地址空间是一对一的线性地址，一个页号的物理快对应一个一块内存空间，而分段需要给出段号基址和段内地址才能确定一个内存地址。

** 虚拟存储器
   :PROPERTIES:
   :CUSTOM_ID: 虚拟存储器
   :END:

所谓虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。
-
请求调入功能与置换功能：当此时内存已满，无法在装入新的页，可以通过置换算法将不需要使用的页面置换出去；
这样就会让用户以为内存好像是永远都用不完的一样，这种存储器被称为虚拟存储器。

*** 虚拟存储器的实现
    :PROPERTIES:
    :CUSTOM_ID: 虚拟存储器的实现
    :END:

-  请求分页系统：在分页系统的基础上，增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。其允许值装入少量页面的程序就可以先运行，之后，在通过调页功能和置换功能，陆续把要运行的页面调入内存，而把暂时不用的页面调出去。置换是以页面为单位。
-  请求分段系统：在分段系统的基础上，增加了请求调页功能和分段置换功能所形成的短时虚拟存储系统。

** 页面置换算法
   :PROPERTIES:
   :CUSTOM_ID: 页面置换算法
   :END:

虚拟存储器中页（段）置换功能是如何进行的呢？置换算法的好坏，决定这系统的性能好坏。

*** 先进先出页面置换算法（FIFO）
    :PROPERTIES:
    :CUSTOM_ID: 先进先出页面置换算法fifo
    :END:

总是淘汰最先进入内存的那个页面。

*** 最佳置换算法
    :PROPERTIES:
    :CUSTOM_ID: 最佳置换算法
    :END:

理论上的一种算法，淘汰的页面的以后将不再使用的，或是以后最长时间不再使用的。

*** 最近最久未使用置换算法（LRU）
    :PROPERTIES:
    :CUSTOM_ID: 最近最久未使用置换算法lru
    :END:

最近使用过的页面不被淘汰，淘汰使用间隔最久的页面。

** 感受
   :PROPERTIES:
   :CUSTOM_ID: 感受
   :END:

怎么说呢，感谢我参考博文的作者，谢谢他总结这么仔细让我可以一次性顺了这么多知识点，感觉把好多的知识碎片都串起来了！






