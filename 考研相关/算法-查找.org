[[file:index.org][{back to main page}]]
#+HTML_HEAD: <link rel="stylesheet" typ="text/css" href="/home/hiro/org/css/worg.css"/>
#+TITLE: 算法 查找

#+DATE: 2017-05-03 21:50:52

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/home/hiro/org/css/worg.css"/>

学习查找算法和关于查找的一些数据结构。 @@html:<!--more-->@@

** 符号表
   :PROPERTIES:
   :CUSTOM_ID: 符号表
   :END:

存储键值对的数据结构，支持两种操作：插入（将新的键值对插入到符号表中），查找（根据给定的
key 返回相应的值）。

** 基于无序链表的顺序查找
   :PROPERTIES:
   :CUSTOM_ID: 基于无序链表的顺序查找
   :END:

需要定义一个内部结点类，包含一个 key 和多个
value，还必须要有一个指向下一结点的引用。 核心操作（查找 get）：

#+BEGIN_SRC java
    // first 为第一个结点
    public Value get(Key key) {
        for (Node x=first; x!=null; x=x.next) {
            if (key.equals(x.key)) {
                return x.value;
            }
        }
        return null;
    }
#+END_SRC

核心操作（插入 put）：

#+BEGIN_SRC java
    public void put(Key key, Value value) {
        for (Node x=first; x!=null; x=x.next) {
            if (key.equals(x.key)) {
                x.value = value;
                return;
            }
        }
        first = new Node(key, value, first);
    }
#+END_SRC

删除操作（delete）：

#+BEGIN_SRC java
    public Value delete(Key key) {
        // 第一个 if 判断是我自己加的，感觉原来的没有覆盖 first 结点
        if (key.equals(first.key)) {
            Value value = first.value;
            first = first.next;
            return value;
        }

        // 这里判断条件和前面两个不一样，因为在删除结点时需要用到删除结点的前一个结点
        for (Node x=first; x.next!=null; x=x.next) {
            if (key.equals(x.next.key)) {
                x.next = x.next.next;
                return x.next.value;
            }
        }
        return null;
    }
#+END_SRC

命题一：在含有 N 对键值对的无序链表的符号表中，未命中的查找和插入都需要
N 次比较。命中的查找在最坏情况下需要 N 次比较。 命题二：向一个空表中插入
N 个不同的键值对需要 =N^2/2= 次比较

** 基于有序数组的二分查找
   :PROPERTIES:
   :CUSTOM_ID: 基于有序数组的二分查找
   :END:

-  平行的两个数组，即 key 放一个数组 keys，value 放一个数组
   values，相同位置的 key 对应相同位置的 value
-  通过二分查找来是数组有序
-  插入操作，通过二分查找找到 key 的位置，如果存在
   key，更新值；不存在，在该位置插入

核心算法（rank）（递归）：

#+BEGIN_SRC java
    // 切记，在 low 和 high 相等时还需要有一次和 key 的比较
    public int rank(Key key, int low, int high) {
        if (high < low) return low;
        int mid = low + (high-low)/2;
        int cmp = key.compareTo(keys[mid]);
        if (cmp > 0) rank(key, mid+1, high);
        else (cmp < 0) rank(key, low, mid-1);
        else return mid;
    }
#+END_SRC

核心算法（rank）（迭代）：

#+BEGIN_SRC java
    public int rank(Key key) {
        int low = 0;
        int high = N;

        while (low <= high) {
            int mid = low + (high-low)/2;
            int cmp = key.compareTo(keys[mid]);
            if (cmp > 0) {
                low = mid + 1;
            } else if (cmp < 0) {
                high = mid - 1;
            } else return mid;
        }
        return low;
    }
#+END_SRC

命题一：在 N 个键值对的有序数组中进行二分查找最多需要 =lgN+1=
次比较（无论是否成功） 命题二：向大小为 N
的有序数组中插入一个元素在最坏情况下需要 2N 次操作。
命题三：向一个空符号表中插入 N 个元素最坏情况下需要访问数组 =N^2= 次。

** 二叉查找树
   :PROPERTIES:
   :CUSTOM_ID: 二叉查找树
   :END:

每个结点都包含一个可以比较的 key，每个结点的 key
都大于其左子数的所有结点的 key，小于其右子树的所有结点的 key。

代码实现很多......大都是使用递归，放在了 github，地址：
https://github.com/nicehiro/Algorithm/blob/master/Search/BinarySearchTree.java

命题一：由 N 个随机键构成的二叉查找树中，查找命中平均所需比较次数为
=2lnN ~ 1.39lgN= 命题二：由 N
个随机键构成的二叉查找树中，查找未命中和插入操作平均所需比较次数为
=2lnN ~ 1.39lgN=

*** 改进：平衡二叉树
    :PROPERTIES:
    :CUSTOM_ID: 改进平衡二叉树
    :END:

当我们可以确定左右子树都是平衡二叉树，且左右子树深度之差不超过
1，此树被称为平衡二叉树。
更普通的来讲，一个平衡二叉树的每个结点的值都是以此结点为根节点的子树的中位数。

我们可以先对一个数组进行排序，再通过二分查找，一次放到子节点中来构造平衡二叉树。
http://algs4.cs.princeton.edu/32bst/PerfectBalance.java.html

也可以通过左旋、右旋平衡处理来构造一个平衡二叉树。参考严老师数据结构
P234 代码繁多见 github：
https://github.com/nicehiro/Algorithm/blob/master/Search/BalanceBinarySearchTree.java

** 完美平衡二叉树
   :PROPERTIES:
   :CUSTOM_ID: 完美平衡二叉树
   :END:

这是我长这么大写的最复杂的一段代码！没有之一！
其实可以这么说，红黑二叉树就是上面严老师教材中的平衡二叉树的另一种实现。
### 2-3 查找树 - 一棵完美平衡的 2-3
查找树中所有空链接到根节点的距离都是相同的。 - 2- 结点，有一个
key，两条链接，大于和小于 - 3- 结点，有两个
key，三条链接，大于最大，小于最小，介于之间 - 向 2- 结点插入：直接变为
3- 结点 - 向 3- 结点插入：分解为 3 个 2- 结点 - 向父节点为 2- 结点的 3-
结点插入：分解 3- 结点，并与父 2- 结点合并 - 向父节点为 3- 结点的 3-
结点插入：分解 3- 结点，与父 3- 结点合并，再分解，知道不出现 4- 结点

命题一：在一棵大小为 N 的 2-3 树中，查找和插入操作访问结点不超过 lgN
次。

*** 红黑二叉树
    :PROPERTIES:
    :CUSTOM_ID: 红黑二叉树
    :END:

-  红链接均为左链接
-  没有任何一个结点同事和两条红链接相连
-  完美黑色平衡，即每一个空链接到根节点的路径上的黑链接数量相同

2-3 查找树实现需要付出的成本有些高（空间），所以采取了这种方法。其实一个
3- 结点就是一个红链接相连的两个 2- 结点。 github 地址：
https://github.com/nicehiro/Algorithm/blob/master/Search/RedBlackTree.java

命题一：一棵大小为 N 的红黑树的高度不会超过 2lgN 命题二：一棵大小为 N
的红黑树中，根节点到任意结点的平均路径长度为 lgN 感觉就很霸气： >
想想看，这样的保证是一个非凡的成就。在信息世界的汪洋大海中，表的大小可能上千亿，但我们仍能够确保在几十次比较之内就完成这些操作。

** 散列表
   :PROPERTIES:
   :CUSTOM_ID: 散列表
   :END:

使用 Hash
函数，得到某一元素唯一的值，通过这个值将元素插入到对应数据结构中合适的位置。

*** 基于线性探测法的散列表
    :PROPERTIES:
    :CUSTOM_ID: 基于线性探测法的散列表
    :END:

-  利用数组中的空位解决碰撞冲突
-  命中：该位置的键值和查找的键值相同
-  未命中：该位置没有键
-  继续查找：该位置的键与查找的键不相同

见 github：
https://github.com/nicehiro/Algorithm/blob/master/Search/SeparateChainingHashST.java

*** 基于拉链法的散列表
    :PROPERTIES:
    :CUSTOM_ID: 基于拉链法的散列表
    :END:

其实就是邻接表法。 - 根据散列值确定对应的链表 - 在链表上一一查找

见 github：
https://github.com/nicehiro/Algorithm/blob/master/Search/LinearProbingHashST.java

** 分析
   :PROPERTIES:
   :CUSTOM_ID: 分析
   :END:

| 算法                   | 最坏情况查找   | 最坏情况插入   | 平均情况查找命中   | 平均情况插入   |
|------------------------+----------------+----------------+--------------------+----------------|
| 顺序查找（无序链表）   | N              | N              | N/2                | N/2            |
| 二分查找               | lgN            | N              | lgN                | N/2            |
| 二叉树查找             | N              | N              | 1.39lgN            | 1.39lgN        |
| 红黑树查找             | 2lgN           | 2lgN           | lgN                | lgN            |
| 拉链法                 | <lgN           | <lgN           | N/2M               | N/M            |
| 线性表探测法           | clgN           | clgN           | <1.5               | <1.5           |

** 感受
   :PROPERTIES:
   :CUSTOM_ID: 感受
   :END:

红黑树那里的 delete
操作真的是看了有一天，到现在也是模模糊糊半懂不懂的状态。那个算法是真的抽象。不过可以结合
2-3 树的分析来看，毕竟红黑树的本质是一棵 2-3 树。






