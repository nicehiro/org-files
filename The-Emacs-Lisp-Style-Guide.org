#+HUGO_BASE_DIR: ~/Documents/blog/
#+hugo_section: posts
#+hugo_auto_set_lstmod: t

#+TITLE: 译：Emacs 编码风格指南

#+DATE: 2018-02-19
#+OPTIONS: toc:nil

#+BEGIN_QUOTE
Role models are important.
-- Officer Alex J.Murphy / RoboCop
#+END_QUOTE

这套 Emacs Lisp 编码风格建议最佳的编码体验，可以让 Emacs Lisp 程序员写出容易被其他 ELisp 程序员容易维护的代码。反映世界使用情况的风格指南已经被使用...(此不翻译不通)

这套指南根据不同的规则分为不同的章节，并且井可能的添加规则背后的原理（如果有忽略的原理，那就是他太明显了。）

这套代码风格大部分基于我作为专业软件工程师的广泛职业生涯，来自 Emacs Lisp 社区成员的反馈和建议，以及备受推崇的 Emacs Lisp 编程资源，例如“GNU Emacs Lisp”参考手册。

这套规则仍然在继续开发中，有些章节正在消失，有些章节有待完善，还有些章节缺少生动的例子，更有些章节根本没有例子以至于讲得规则不很清晰。在适当的时候，这些问题将会被解决（addressed）--现在先把他们记下来。

请注意，Emacs 开发人员也维护了一系列代码约定和技巧。

你可以使用 [[https://github.com/TechnoGate/transmuter][Transmuter]] 生成这份指南的 PDF 或 HTML 文档。

#+TOC: headlines 2

** 源代码布局和组织

#+BEGIN_QUOTE
几乎每个开发者都确信：除了他们自己的代码风格其他人写的代码都是丑陋、不合理的。前面这句话除去“除了他们自己”或许才是对的……
-- Jerry Coffin
#+END_QUOTE

如果您使用 Emacs 编写代码，此处制定的缩进指南可以视作是理所当然的。当你敲 =<tab>= 时，Emacs总是会做正确的事。

- 使用 *空格键* 缩进。不要对 tab 进行硬编码[1]。
- 对于正规的函数，垂直对齐函数参数。
  #+BEGIN_SRC elisp
  ;; good
  (format "%s %d"
          something
          something-else)

  ;; bad
  (format "%s %d"
    something
    something-else)
  #+END_SRC
- 如果第一个参数在新起的一行上，将它与函数名对齐[2]。
  #+BEGIN_SRC elisp
  ;; good
  (format
   "%s %d"
   something
   something-else)

  ;; bad 
  (format
    "%s %d"
    something
    something-else)
  #+END_SRC
  
- 有些表达式很特殊，有一个或者多个特殊的参数跟在主体参数（ =body= ）前面（任意数量的参数，只有返回值是重要的），比如说： =if= 、 =let= 、 =with-current-buffer= 等。特殊参数要么和表达式名处于同一行，要么缩进4个字符。主体参数应该缩进2个字符。
  #+BEGIN_SRC elisp
  ;; good
  (when something
    (something-else))
  
  ;; bad - 主体参数 4 个空格
  (when something
      (something-else))

  ;; bad - 像普通的函数那样对齐
  (when 
   something
   (something-else))
  #+END_SRC
  
- 注意到 =if= 表达式的“if”子句是一个特殊表达式，用 4 个空格缩进。
  #+BEGIN_SRC elisp
  ;; good
  (if something
      if-clause
    else-clause)

  ;; bad
  (if something
    if-clause
    else-clause)
  #+END_SRC
  
- 垂直对齐 =let= 的 bindings。
  #+BEGIN_SRC elisp
  ;; good
  (let ((thing1 "some stuff")
        (thing2 "other stuff"))
    ...)

  ;; bad
  (let ((thing1 "some stuff")
    (thing2 "other stuff"))
    ...)
  #+END_SRC
  
- 使用 Unix 风格的行尾。（BSD/Solaris/Linux/OSX 用户默认被覆盖，Windows 用户必须格外小心。）
  - 如果您使用 Git，您可能需要添加以下配置设置，以保护您的项目免于被Windows搞：
    #+BEGIN_SRC sh
    bash$ git config --global core-autocrlf true
    #+END_SRC

- 如果任何文本在前半块括号（(，{，[）之前，就用空格将文本与括号分开；相反的，如果任何文本在前半块括号之后或是在后半块括号之前，不要添任何空格。
  #+BEGIN_SRC elisp
  ;; good
  (foo (bar baz) quux)

  ;; bad
  (foo(bar baz)quux)
  (foo ( bar baz ) quux)
  #+END_SRC
  
- 把所有的尾括号都放在最后一个语句行上，别新起一行。
  #+BEGIN_SRC elisp
  ;; good single line
  (when something
    (something-else))

  ;; bad; distinct lines
  (when something
    (something-else)
  )
  #+END_SRC
  
- 在两个表达式之间空行。
  #+BEGIN_SRC elisp
  ;; good
  (defvar x ...)

  (defun foo ...)

  ;; bad
  (defvar x ...)
  (defun foo ...)
  #+END_SRC

  当然也有例外。当连着写多个 =def= 表达式时候可以不空行。
  #+BEGIN_SRC elisp
  ;; good
  (defconst min-rows 10)
  (defconst max-rows 20)
  (defconst min-cols 15)
  (defconst max-cols 30)
  #+END_SRC
  
- 不要在一个函数或者是一个宏定义之间插入空行。当然也有例外，比如在 =let= 和 =cond= 中空行来进行分组。

- 如果可以，避免让每一行长度不超过 80 个字符。

- 避免每条语句后尾随空白。

- 避免超过三个或四个位置参数的参数列表。

- 始终启用词法范围。可以在第一行定义当作文件当地变量。
  #+BEGIN_SRC elisp
  ;;; -*- lexical-binding: t; -*-
  #+END_SRC


** 句法

- 不要用 =progn= 包裹 =if= 语句的 else 子句。
  #+BEGIN_SRC elisp
  ;; good
  (if something
      if-clause
    (something)
    (something-else))
    
  ;; bad
  (if something
      if-clause
    (progn 
      (something)
      (something-else)))
  #+END_SRC

- 使用 =when= 而不是 =(if ... (progn ...))= 。
  #+BEGIN_SRC elisp
  ;; good
  (when pred
    (foo)
    (bar))

  ;; bad
  (if pred
    (progn
      (foo)
      (bar)))
  #+END_SRC
  
- 使用 =unless= 而不是 =(when (not ...) ...)= 。
  #+BEGIN_SRC elisp
  ;; good
  (unless pre
    (foo)
    (bar))

  ;; bad
  (when (not pred)
    (foo)
    (bar))
  #+END_SRC
